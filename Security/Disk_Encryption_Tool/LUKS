### ===========================================================================LUKS硬盘加密1
LUKS （Linux Unified Key Setup）是 Linux 硬盘加密的标准。 
通过提供标准的磁盘格式，它不仅可以促进发行版之间的兼容性，
还可以提供对多个用户密码的安全管理。 
与现有解决方案相比，LUKS 将所有必要的设置信息存储在分区信息首部中，
使用户能够无缝传输或迁移其数据。

### ===========================================================================安装加密软件
通常的发行版已经预装了该软件包，可以直接使用，下面是 Gentoo 的安装方法
# emerge --ask sys-fs/cryptsetup

### ===========================================================================创建加密分区
注意，该操作会清空你选择分区或设备上的所有数据，请谨慎操作，输入大写的 YES 确认
# cryptsetup -s 512 luksFormat /dev/sdd

WARNING!
========
This will overwrite data on /dev/sdd irrevocably.

Are you sure? (Type uppercase yes): YES
Enter passphrase: 
Verify passphrase:
    
    
### ===========================================================================利用key-file加密分区 
除了密码之外，还可以选择使用 key file 解密你的硬盘，也就是相当于一个密钥，
当然可以也可以只使用 key file 或者同时使用密码与 key file
_______________________________________________________________________________
生成随机 key file
# dd if=/dev/urandom of=/root/enc.key bs=1 count=4096

### ===========================================================================添加 key file 作为密码之一
# cryptsetup luksAddKey  /dev/sdd /root/enc.key
Enter any existing passphrase:

### ===========================================================================移除解密密码
移除普通密码
# cryptsetup luksRemoveKey /dev/sdd
Enter LUKS passphrase to be deleted: ...
_______________________________________________________________________________
移除 key file 密码
# cryptsetup luksRemoveKey -d /root/enc.key /dev/sdd
_______________________________________________________________________________
注意：千万不要将所有密码移除，至少需要留有一个密码访问设备，移除操作不可撤销


### ===========================================================================解密分区设备

1 密码解密
# cryptsetup luksOpen /dev/sdd myusb
Enter passphrase for /dev/sdd:
_______________________________________________________________________________
2 key file 解密
# cryptsetup luksOpen -d /root/enc.key /dev/sdd myusb

### ===========================================================================创建文件系统
在挂载使用之前，我们仍然需要对设备创建文件系统才可以使用，可以选择任何你喜欢的文件系统，
例如 btrfs，ext4，vfat，ntfs, xfs,等
# mkfs.ext4 /dev/mapper/myusb
mke2fs 1.43.6 (29-Aug-2017)
Creating filesystem with 488448 4k blocks and 122160 inodes
Filesystem UUID: 995e172a-2bc6-432c-a60f-2d4d7093e748
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376, 294912

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

### ===========================================================================挂载加密分区设备
现在可以像正常分区一样挂载我们的加密分区设备了
# mount /dev/mapper/myusb /mnt/
# df -h
/dev/mapper/myusb  1.9G  5.7M  1.7G   1% /mnt

### ===========================================================================卸载挂载点并关闭加密分区
# umount /mnt
# cryptsetup luksClose myusb




### ===========================================================================LUKS硬盘加密2
◇用 LUKS 方式加密（格式化）该文件容器
使用前面章节提及的参数，对上述文件容器进行加密。得到一个虚拟的加密盘。
~#    cryptsetup --cipher aes-xts-plain64 --key-size 512 --hash sha512 --iter-time 10000 luksFormat /root/luks.vol


### ===========================================================================
◇打开加密之后的文件容器
使用如下命令打开上述的文件容器，使用的映射名是 xxx（你也可以改用其它单词）。
~#    cryptsetup luksOpen /root/luks.vol xxx
打开之后，该虚拟盘会被映射到 /dev/mapper/xxx
你可以用如下命令看到：
~#    ls /dev/mapper/

    
### ===========================================================================   
◇创建文件系统
由于加密盘已经打开并映射到 /dev/mapper/xxx 你可以在 /dev/mapper/xxx 之上创建文件系统。
命令如下（文件系统类型以 ext4 为例）
~#    mkfs.ext4 /dev/mapper/xxx
    
    
### ===========================================================================   
◇挂载文件系统
创建完文件系统之后，你还需要挂载该文件系统，才能使用它。挂载的步骤如下。
首先，你要先创建一个目录，作为【挂载点】。俺把“挂载点”的目录设定为 /mnt/xxx（当然，你可以用其它目录作为挂载点）。
    mkdir /mnt/xxx
创建好“挂载点”对应的目录，下面就可以进行文件系统的挂载。
    mount /dev/mapper/xxx /mnt/xxx
挂载好文件系统，用如下命令查看，就可以看到你刚才挂载的文件系统。
    df -hT
接下来，你就可以通过 /mnt/xxx 目录去访问该文件系统。
当你往 /mnt/xxx 下面创建下级目录或下级文件，这些东东将被存储到该虚拟加密盘上。


### ===========================================================================
◇退出
当你使用完，要记得退出。包括下面两步：
卸载文件系统
~#    umount /mnt/xxx
关闭加密盘
~#    cryptsetup close xxx    
    
    
    
   
### ===========================================================================
★LUKS 加密盘使用 keyfile 作为认证因素
◇啥是“keyfile 认证因素”？
其实这个概念，在当年扫盲 TrueCrypt 的教程中（《TrueCrypt——文件加密的法宝》）已经有提及。今天俺再重复罗嗦一下。
传统的“密码认证”用的是一串密不示人的字符串作为认证因素。密码的缺点：
1.当你密码设置得比较短，容易被暴力破解。
2.不好记。尤其当你为了防范暴力破解，把密码设置得很复杂，于是就更不好记了。
　而“keyfile 认证”就是用一个文件来替代密码，可以解决密码的上述两个缺点。



### ===========================================================================
◇什么文件作“keyfile”比较合适？
用信息学的术语来讲就是：文件内容的“熵值”越大，越适合作 keyfile。换用通俗的人话来讲就是：文件内容越紊乱越随机，就越适合。
通常而言，二进制可执行文件（比如 exe）、图片文件（比如 JPG、PNG、GIF）、视频文件，都可以用来作 keyfile。
对于 Linux 的用户，可以用如下命令生产一个【内容完全随机】的文件，作为 keyfile 使用。
~#    dd if=/dev/urandom of=/放置keyfile的文件路径 bs=1k count=64
(上述命令生产的文件大小是 64KB，你可以自行设定其它尺寸，但是【不要】小于1KB)
另外，【不建议】用纯文本文件作 keyfile——因为纯文本文件的“熵值”通常都不够大。



### ===========================================================================
◇预备知识——关于“Key Slot”
在继续介绍 keyfile 之前，稍微聊点预备知识。
LUKS 格式的加密盘，默认会提供8个“Key Slot”（编号从0到7）。每个“Key Slot”好比是一个独立的钥匙——都可以用来打开这个 LUKS 加密盘。
你可以用如下命令，查看某个 LUKS 加密盘的“Key Slot”。
~#    cryptsetup luksDump 已加密的物理设备或逻辑设备
如果你刚才已经尝试过创建一个 LUKS 加密盘，用了这个命令之后，
你会发现8个“Key Slot”中，头一个（编号为0的那个）已经被用掉了（显示为“ENABLED”），
其它7个还没用（显示为“DISABLED”）。因为你刚才创建加密盘的时候，已经设置过一次密码，所以用掉了一个“Key Slot”。



### ===========================================================================
◇如何给 LUKS 加密盘增加 keyfile 认证？
明白了“Key Slot”之后，咱们可以开始给 LUKS 加密盘增加新的“Key Slot”。
采用如下命令，可以指定某个文件作为 keyfile，并指派为某个 LUKS 加密盘的认证因素。
~#    cryptsetup luksAddKey 已加密的物理分区或虚拟盘 所用keyfile的路径
再次使用前一小节提及的 luksDump 查看一下，你会发现：又有一个“Key Slot”被用掉了。



### ===========================================================================
◇如何用 keyfile 打开 LUKS 加密盘？
如果你执行完前一个小节的步骤（设定了 keyfile），接下来就可以用如下命令打开该 LUKS 加密盘。
~#    cryptsetup --key-file 所用keyfile的路径 luksOpen 已加密的物理分区或虚拟盘 映射名
(此时，你既可以用密码打开，也可以用 keyfile 打开)




### ===========================================================================
◇如何删除“Key Slot”？
采用如下命令，可以删除某个 LUKS 加密盘的“Key Slot”。
~#    cryptsetup luksKillSlot 已加密的物理分区或虚拟盘 Slot的编号
(再次提醒：编号是从0到7，头一个 Slot 的编号是0)
再次使用前一小节提及的 luksDump 查看一下，你会发现：某个“Key Slot”被删除了。





### ===========================================================================   
★用 cryptsetup 操作 TrueCrypt/VeraCrypt 的加密盘
（再次罗嗦：cryptsetup 的版本号需要【大于等于 1.6.0】才能兼容 TrueCrypt/VeraCrypt 加密盘）
◇基本命令
在前面的“功能概述”中提及：dm-crypt/cryptsetup 可以用来打开 TrueCrypt/VeraCrypt 加密盘。
命令行的大致写法如下：
~#    cryptsetup open --type tcrypt 已加密的物理分区或虚拟盘 映射名
　　也可以使用简写的方式如下：
~#    cryptsetup tcryptOpen 已加密的物理分区或虚拟盘 映射名
 
◇相关参数
在 TCRYPT 模式下，有一些相关的参数，简要说明如下：
_______________________________________________________________________________
参数名称              说明                                           参数值
--tcrypt-hidden     打开隐藏卷，需要追加该参数 	                         无
--tcrypt-system     打开加密的系统分区，需要追加该参数 	                 无
--readonly          以“只读”方式打开加密分区，需要追加该参数 	             无
--key-file          如果该加密盘用到了“keyfiles”认证，需要追加该参数       keyfile 的路径
--veracrypt         打开 VeraCrypt 格式的加密盘，需要追加该参数           无

关于 VeraCrypt 的补充说明：
cryptsetup 的版本号要大于等于 1.6.7 才可以打开 VeraCrypt 的加密盘。
由于这个功能是近期才加入 dm-crypt/cryptsetup，
好像还不支持 VeraCrypt 的 PIM 功能——（俺简单测试了一下）如果 VeraCrypt 加密盘设置了 PIM，用 cryptsetup 对其进行 open 操作，
没有提示俺输入 PIM，然后显示打开失败。
估计要等 cryptsetup 更新的版本，或许就会支持 VeraCrypt 加密盘的 PIM 功能。
{关于 PIM 功能，参见《扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品》}




### ===========================================================================
### ===========================================================================
### ===========================================================================
★用 cryptsetup 加密系统分区（root filesystem）或全盘加密

◇配置方法

在本文开头，俺已经说了——这篇教程面向技术菜鸟。而“加密系统分区”对技术菜鸟来讲，有一定难度。
万一没搞好，可能会把系统搞坏掉（导致 Linux 系统无法启动）。
咋办捏？俺帮大伙儿想了一招比较简单的玩法——在安装系统的时候，加密系统分区（甚至全盘加密）。
能否使用这招，要看具体的 Linux 发行版，在安装过程中是否提供相应的功能。
如果俺没记错的话，如下几个主流的发行版，是可以在安装过程中加密系统分区或全盘加密的。
（如果你觉得俺列举的发行版，有遗漏，欢迎到博客留言进行补充）

    Debian
    Fedora
    Ubuntu
    Linux Mint
    CentOS
    RedHat Enterprise Linux
由于不同的发行版，安装界面各不相同，所以俺就偷懒一下，不提供截图了。
大体上，这些发行版的安装过程，都有一个步骤是“硬盘分区”。在这个步骤，会提供相关的“加密选项”。
对于想要进行全盘加密的同学，装系统过程中进行分区的时候，
要把 /boot 单独分一个区。并且这个分区是【不能】加密的——因为 /boot 要用来放置引导管理器与内核。


### ===========================================================================
◇“全盘加密”的弱点

从理论上讲：任何一种磁盘加密工具，（在不借助外部机制的情况下）都【不可能】实现真正的“自启动全盘加密”。
为啥捏？因为要想【自启动】，必须要有一个引导程序，至少这个引导程序不能加密（引导程序如果被加密了，就无法引导了）。
所以，凡是能够实现“自启动全盘加密”的，其【引导程序】都是明文的（无加密的）

比如 TrueCrypt 和 VeraCrypt 进行全盘加密，都会替换原有的主引导扇区的内容，在里面放入一段代码。
这段代码会在开机启动的时候，提示你输入密码，然后用你输入的密码进行解密。

对于 dm-crypt 的全盘加密，除了“主引导扇区”【没有】加密，还包括 /boot 分区也【没有】加密（因为启动管理器放置在 /boot 分区）。
如前所述，这些【没有加密】的部分，会成为攻击者瞄准的弱点。

攻击举例：
如果某个攻击者可以物理接触你的电脑，此人完全可以把你硬盘上的引导程序替换为一个假的引导程序。
当你开机启动的时候，这个【假的】引导程序照样会提示你输入解密的密码。如此一来，你的密码就泄漏了。



### ===========================================================================
◇如何防范“全盘加密的弱点”

常规的防范措施有如下几种：
采用 BIOS 提供的“硬盘口令”功能
一般而言，台式机没有这个功能；大部分商用笔记本有这个功能。
这个功能的安全性如何，要看具体的笔记本品牌（不同厂商的实现，可能不一样，因此安全性也不一样）。
如果这个功能比较靠谱，就可以防止攻击者在你不知情的情况下，替换你硬盘上的引导程序。


### ===========================================================================
采用外部存储介质进行引导
简而言之，就是把引导程序放到【可引导的】外部介质（比如 U盘、SD卡、MMC卡）。
先用外部介质进行引导，然后通过外部介质中的引导程序，提示你输入密码，然后解密硬盘，最后再启动硬盘上的操作系统。

对于“U盘/SD卡/MMC卡”而言，因为可以随身携带或隐藏在某处，被攻击者物理接触的风险会降低。
对于 TrueCrypt/VeraCrypt【没法】用这招。而对于 dm-crypt，可以用这招。这种玩法略显复杂，不适合菜鸟。
考虑到本文是“扫盲性质”的教程，暂且不提。


### ===========================================================================
把系统安装到外部存储介质
这种玩法就是把【整个操作系统】都安装到外部存储介质（比如 U盘、SD卡、MMC卡）。
开机时，需要先插入外部存储介质，启动整个操作系统。然后在这个操作系统中内置的 dm-crypt 挂载加密的硬盘。

对于“U盘/SD卡/MMC卡”而言，因为可以随身携带或隐藏在某处，被攻击者物理接触的风险会降低。
很多主流的 Linux 发行版，默认提供了 Live CD 的功能（也就是用光盘直接启动出一个【可用】的 Linux 环境）
对这类发行版，你可以用工具把 Live CD 的 ISO 镜像文件“烧制”到 U盘/SD卡/MMC卡。
然后就可以用来启动电脑。具体的教程参见《如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）》。




### ===========================================================================
★混用 dm-crypt 和 TrueCrypt/VeraCrypt


在本文结束前，俺最后聊一下如何混用 dm-crypt 和 TrueCrypt/VeraCrypt。
◇为啥要混用？


在本文开头部分给出了一个“功能对比”的清单，从中可以看出 dm-crypt 和 TrueCrypt/VeraCrypt 各有独到之处。
比如 dm-crypt 可以用来加密 Linux 的系统分区（root filesystem），而 TrueCrypt 和 VeraCrypt 都做不到；
反之，TrueCrypt 和 VeraCrypt 提供了“隐藏卷”的功能。可以用该功能来实现“Plausible Deniability”（介绍参见“这里”），而 dm-crypt 做不到这点。
因此，有必要组合这两者。


◇“dm-crypt + TrueCrypt” VS “dm-crypt + VeraCrypt”


截止俺写本文的时候，TrueCrypt 的 Linux 版本【尚未发现】高危漏洞，所以你如果要继续使用 Linux 下的 TrueCrypt，也是可以的。
但是考虑到 TrueCrypt 已经停止维护，长远来讲，还是建议用“dm-crypt + VeraCrypt”这个组合进行混用。
另外，VeraCrypt 增加了 PIM 功能来对抗暴力破解。对那些安全要求非常高的同学，这个“PIM 功能”也是有吸引力的。
（关于 PIM 功能，参见《扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品》）



### ===========================================================================
◇混用的思路


首先用 dm-crypt/cryptsetup 对系统分区（root filesystem）进行加密 或者 实现全盘加密。（具体玩法参见前面的章节）
然后在已经加密的分区中，创建 TrueCrypt/VeraCrypt 的虚拟加密盘，并使用隐藏卷的功能。
（如何使用隐藏卷，参见《TrueCrypt 使用经验[4]：关于隐藏卷的使用和注意事项》）
把你最敏感最重要的数据，存储在隐藏卷中。
假设将来有一天，你受到胁迫，你可以交出 dm-crypt 的加密密码。
然后利用隐藏卷这个功能，来施展“Plausible Deniability”的技巧，迷惑胁迫你的人。
关于该技巧的使用场景，参见这篇博文中的“◇Plausible Deniability”章节。



### ===========================================================================
★如果你对 TrueCrypt/VeraCrypt 不放心，该咋办？


本来这个话题应该是放到之前那篇博文来聊的。但是在写前面那篇博文的时候，俺还没有扫盲“dm-crypt/cryptsetup”。所以只好把这个话题留到今天这篇博文。

◇某些用户的担心

从俺博客的读者留言中，可以看出某些人对这两款工具都不太放心。
TrueCrypt, 虽然历史悠久，口碑极好。但是官网已经宣布“停止维护”。而且上个月底（9月底）刚曝光了 Windows 版本的高危漏洞。
VeraCrypt, 因为这个开源项目的历史比较短，有些同学担心这个项目会不会是一个蜜罐项目。

◇俺的分析
先不管这两个软件在【代码层面】是否有后门，咱们先来说【加密盘的格式】。
“加密盘格式”与“程序代码”不同。“加密盘格式”是很少变化的（基本是静态的），而“程序代码”会随着软件版本的升级，
而不断发生变化——有可能这个版本没有后门，但是下一个版本就被植入后门。


“TrueCrypt 的加密盘格式”已经被很多安全专家研究过。包括这两年安全界发起了对 TrueCrypt 的安全审计，其中一项工作就是：评估加密盘的格式。
到目前为止，至少【没有】发现该格式有明显的后门或弱点。
综上所述，俺认为 TrueCrypt 的加密盘格式是可靠的（可信的）。

而 VeraCrypt 的加密盘格式，跟 TrueCrypt 的格式几乎完全一样——俺专门看过这两者的技术规范文档，
加密盘头部（header）的结构完全一样，仅有的差异在于某个标志位（从 TrueCrypt 的标志改为 VeraCrypt 的标志）。
　　因此，VeraCrypt 的加密盘格式，也是可靠的（可信的）
　　
　　

### ===========================================================================　
◇防范措施


　　基于上述分析，有一个策略可以帮你规避 TrueCrypt/VeraCrypt【软件本身】潜在的后门。具体步骤如下：

　　1.你在某个操作系统虚拟机中，安装好 TrueCrypt 或 VeraCrypt。
　　2.使用虚拟机中的 TrueCrypt 或 VeraCrypt 帮你创建【虚拟】加密盘。
　　3.把创建好的【虚拟】加密盘 copy 到你的 Linux 环境中，用 dm-crypt 打开加密盘进行使用。
　　4.如果需要修改加密盘的密码或 keyfile，再把【虚拟】加密盘 copy 回操作系统虚拟机中，用 TrueCrypt 或 VeraCrypt 修改密码或 keyfile。

　　基于上述步骤，你的 Linux 系统中完全不会运行 TrueCrypt 或 VeraCrypt，但是又可以享受这两款软件的强大功能（比如“隐藏卷”、比如“多重加密算法”）。
　　代价就是：操作步骤稍嫌繁琐（需要 copy 虚拟加密盘）。这也是没办法滴——“安全性”和“易用性”通常都是矛盾的。
　　
　　
　　
　　
　　
　　
　　
　　
　　
　　
　　
　　
　　
　　

