### ===========================================================================
#Port 22
#AddressFamily any                  # 指定 sshd应当使用哪种地址族,取值范围是："any"(默认)、"inet"(仅IPv4)、"inet6"(仅IPv6)
#ListenAddress 0.0.0.0              # 指定 sshd监听的网络地址，默认监听所有地址
#ListenAddress ::        

# Logging                           # 指定的日志等级(详细程度)
#SyslogFacility AUTH
#LogLevel INFO

#PermitRootLogin prohibit-password  # 是否允许 root 登录, "yes"(默认) 表示允许。"no"表示禁止
#LoginGraceTime 2m                  # 限制用户必须在指定的时限内认证成功,0表示无限制,默认值是 120 秒
#PubkeyAuthentication yes           # 是否允许公钥认证。仅可以用于SSH-2。默认值为"yes"
#PasswordAuthentication yes         # 是否允许使用基于密码的认证。默认为"yes"
#PermitEmptyPasswords no            # 不允许使用空密码
#PermitRootLogin prohibit-password  # 是否允许 root 登录, "yes"(默认) 表示允许。"no"表示禁止
#LoginGraceTime 2m                  # 限制用户必须在指定的时限内认证成功,0表示无限制,默认值是 120 秒

#GSSAPIAuthentication no            # 是否允许使用基于 GSSAPI 的用户认证。默认值为"no"。仅用于SSH-2。

RSAAuthentication yes               # 开启RSA认证

### ===========================================================================
密钥对认证/

1 由客户端（client）用户在本地创建密钥对

2 上传公钥文件 id_rsa.pub

3 导入公钥信息文件 到服务器端 用户freeysh 公钥数据库中（server）
公钥文件位置：/home/freeysh/.ssh/autorized_keys 
cat id_rsa.pub >> /home/freeysh/.ssh/authorized_keys
chmod 600 /home/freeysh/.ssh/authorized_keys
  	  
4 使用密钥对认证
此时写入要连接的服务器IP，就可以登陆到 用户freeysh中的系统上了

5 服务器端关闭SElinux服务－》option
  vim /etc/selinux/config
  SELINUX=disbale

### ===========================================================================

4、启动SSH服务            /etc/init.d/ssh start 
5、验证SSH服务状态        /etc/init.d/ssh status
6、添加开机自启动         update-rc.d ssh enable
6、关闭自启动为           update-rc.d ssh disabled



     $HOME/.ssh/authorized_keys
             存放 RSA/DSA 公钥, 用户通过它登录机器.  sshd(8) 手册页描述了这个
             文件的格式. 最简单的文件格式和 .pub 身份文件一样.  文件内容并非高
             度敏感, 但是仍然建议仅让此文件的用户读写, 而拒绝其他用户的访问.










描述 (DESCRIPTION)
     ssh (SSH 客户端) 用于登录远程主机, 并且在远程主机上执行命令.  它的目的是
     替换 rlogin 和 rsh, 同时在不安全的网络之上, 两个互不 信任的主机之间, 提供
     加密的, 安全的通信连接.  X11 连接和任意 TCP/IP 端口均可以通过此安全通道转
     发(forward).

     当用户通过 ssh 连接并登录主机 hostname 后, 根据所用的协议版本, 用户必须通
     过下述方法之一向远程主机证明他/她的身份:


SSH 协议第一版
     第一, 如果发出登录命令的本地主机已经列在远程主机的 /etc/hosts.equiv 或
     /etc/ssh/shosts.equiv 文件中, 并且两端的用户名相同, 则立即允许该用户登录.
     第二, 如果远程主机的用户根目录 (home 目录) 下存在 .rhosts 或 .shosts, 并
     且其中有一行包含了客户机的名字和客户机上的用户名, 则允许该用户登录.  一般
     来说, 服务器不允许单独使用这种认证方式, 因为它不安全.

     第二种认证方法是 rhosts 或 hosts.equiv 文件结合基于 RSA 的主机认证. 这意
     味着如果 $HOME/.rhosts, $HOME/.shosts, /etc/hosts.equiv, 或
     /etc/ssh/shosts.equiv 允许登录, 并且如果服务器能够验证客户的主机密钥(host
     key) (参见 文件(FILE) 节的 /etc/ssh/ssh_known_hosts 和
     $HOME/.ssh/known_hosts ), 主机才允许客户登录.  这个认证方法关闭了因 IP 欺
     骗, DNS 欺骗和路由欺骗造成的安全漏洞.  [系统管理员注意: 一般说来
     /etc/hosts.equiv, $HOME/.rhosts, 和 rlogin/rsh 协议的本质是不可靠地, 要安
     全就应该关掉它们.]

作为第三种认证方式, ssh 支持基于 RSA 的认证.  这种方案依托于公开密钥算法:
     密码系统的加密和解密通过不同的密钥完成, 无法 通过加密密钥推导出解密密钥.
     RSA 就是这种密码系统.  每个用户创建一对公开/私密钥匙用于认证.  服务器知道
     用户的公钥, 只有用户知道他自己的私钥.  $HOME/.ssh/authorized_keys 文件列
     出允许登录的(用户的)公钥. 当用户开始登录, ssh 程序告诉服务器它准备使用哪
     对钥匙(公钥)做认证.  服务器检查这只密钥(公钥)是否获得许可, 如果许可, 服务
     器向用户 (实际上是用户面前运行的 ssh 程序) 发出测试, 用用户的公钥加密一个
     随机数. 这个随机数只能用正确的私钥解密.  随后用户的客户程序用私钥解出测试
     数字, 即可证明他/她掌握私钥, 而又无需(把私钥)暴露给服务器.


ssh 能够自动执行 RSA 认证协议. 用户通过运行 ssh-keygen(1) 创建他/她的 RSA
     密钥对. 私钥存放在用户根目录下的 $HOME/.ssh/identity 中, 而公钥存放在
     $HOME/.ssh/identity.pub 中. 随后, 用户应该把 identity.pub 复制到远程服务
     器中, 作为 $HOME/.ssh/authorized_keys 存放到他/她的用户根目录下 (
     authorized_keys 对应传统的 $HOME/.rhosts 文件, 每一行只有一只密钥, 尽管一
     行可以很长).  用户无须密码就可以直接登录. RSA 认证远比 rhosts 认证安全.

     RAS 认证最便捷的用法大概就是使用认证代理(authentication agent) 了. 详见
     ssh-agent(1) 手册页.

     如果这些认证方式都失败了, ssh 就提示用户输入口令(password), 然后把口令送
     到服务器做验证. 由于整个通信过程是 加密的, 因此别人不可能通过侦听网络获得
     这个口令.


SSH 协议第二版
     当用户以协议第二版连接时, 类似的认证方法一样有效. 如果使用了
     PreferredAuthentications 的默认内容, 客户端首先试着用基于主机的认证方法进
     行连接; 如果这个方法失败了 就用公开密钥方法作认证; 最后, 如果它也失败了,
     就进入键盘操作, 试试 用户口令认证.

     这个公开密钥方法类似于上一节描述的 RAS 认证, 并且允许使用 RAS 或 DSA 算
     法: 客户端用他的私钥 ( $HOME/.ssh/id_dsa 或 $HOME/.ssh/id_rsa ) 对会话标
     识符(session identifier)签名, 然后把结果送到服务器.  服务器检查
     $HOME/.ssh/authorized_keys 中是否有匹配的公钥, 如果密钥和签名都正确, 访问
     就可以继续进行.  会话标识符来自共享的 Diffie-Hellman 值, 只有客户端和服务
     器端才知道这个值.

     如果公钥认证失败或无效, 用户口令将会加密后送到远端主机来证明用户的身份.

     另外, ssh 支持基于主机或测试应答的认证方式.

     协议第二版提供附加机制增强保密性 (数据流用 3DES, Blowfish, CAST128 或
     Arcfour 加密) 和完整性 (hmac-md5, hmac-sha1).  注意, 协议第一版缺少强有力
     的机制确保连接的完整性.


 登录会话和远程执行
     服务器接受用户身份后, 服务器即可以执行给定的命令, 也可以让用户登录并给他
     一个正常的 shell. 所有和远端命令或 shell 的通信被自动加密.

     如果分配了伪终端(pseudo-terminal)(普通的登录会话), 用户可以使用后面将 提
     到的 escape 字符.

     如果没有分配伪终端, 则会话是透明的(transparent), 能够可靠的传送二进制数
     据.  大多数系统上, 即使分配了终端, 把 escape 字符设为 “none” 也可以让会话
     透明.

     当远程主机上的命令或 shell 退出时, 会话即结束, 并关闭所有 X11 和 TCP/IP
     连接.  远端程序的返回码做为 ssh 的返回码返回.



  
