### ===========================================================================ＵＭＡＳＫ
系统在用户登录时通过 login 程序调用 pam_umask 模块设置用户默认的 umask。
从 login 程序的配置文件 /etc/login.defs 中我们可以找到 umask 相关的配置
cat /etc/login.defs
_______________________________________________________________________________
umask 命令
umask 是 bash 的一个内置命令，用来显示或设置新建文件/目录的权限掩码(umask)。
前面我们以数字的方式输出了用户默认的 umask 值，这次我们以符号的方式进行输出：
$ umask -S
_______________________________________________________________________________
设置 umask 值
最简单的方式就是为 umask 命令指定一个数字：
$ umask 026
026 的含义为：去掉 group 中的写权限，去掉 other 中的读写权限。
_______________________________________________________________________________
以符号的方式设置 umask 值
下面的命令表示从 group 中去掉写权限，从 other 中去掉读写执行的权限。
注意："=" 号在 umask 命令和 chmod 命令中的作用恰恰相反。在 chmod 命令中，
利用它来设置指定的权限，而其余权限则被删除。
但是在 umask 命令中，将在原有权限的基础上删除指定的权限。
比如下面的命令：
$ umask u=, g=w, o=rwx
_______________________________________________________________________________
保存后重新登录一次，然后查看 umask 的值：
在 ~/.bashrc 文件中为用户设置默认的 umask
如果让用户每次登陆后都执行 umask 命令修改默认的 umask 值是不科学的，
我们可以在用户的 ~/.bashrc 文件中执行 umask 命令，这样用户登录后 umask 的值自动就变成了设置的值。
把下面的命令添加到 ~/.bashrc 文件的最后一行：
umask 026
### ===========================================================================ＡＣＬ
ＡＣＬ权限是为了解决身份不够用的时候，才出现的权限
权限rwx   属主root----------\
权限rwx   属组tgroup---------+/project/
无权限    其它人
备注：属主root和属组tgroup都对/project/有读写执行的权限
      此时又有一个新的用户Freeysh，需要对/project/有R－W，即读执行的权限。
      那么此时就需要用到ACL这个特殊的权限了。
_______________________________________________________________________________
1 查看ACL权限是否开启，默认是开启的
  ＃dump2fs命令是查询指定分区详细文件系统信息的
  ＃－h选项，公显示超级块的信息，而不显示磁盘块组的详细信息
  ＃dump2fs －h ／dev／sda3
  
2 临时开启ACL权限，
  ＃重新挂载根分区，并开启ACL权限
  mount -o remount /

3 永久开启分区ACL权限，
vi /etc/fstab
UUID=300ebc32-da31-4124-bb7e-96530ec964b2　　 /  default,acl        1         1
mount -o remount

4 查看ACL权限命令
getfacl     文件名

5 设置ACL权限命令
setfacl     选项      文件名
            -m          设定ACL权限
            -x          删除ACL权限
            -b          删除所有ACL权限
            -d          设定默认ACL权限          
            -k          删除默认ACL权限
            -R          递归设定ACL权限
_______________________________________________________________________________
mkdir /project
useradd aa
passwd aa
useradd bb
passwd bb
useradd Freeysh
passwd Freeysh
groupadd tgroup                     # 添加一个tgroup 的用户组
gpasswd -a aa tgroup                # aa加入tgroup的组
gpasswd -a bb tgroup                # bb加入tgroup的组
chown root:tgroup /project/         # /project的所属主为root，所属组为tgroup
chmod 770 /project/ 
setfacl -m g:Freeysh:rx /project/   # 使用“g:组名:权限”的格式
___________________________________________________________
getfacl /project                    # 查看ACL权限

1 最大有效权限“mask”，mask是用来指定最在有效权限的，
  如果我们给用户分配了ACL权限就需要和“mask”权限相与，才能得到用户真正的权限。
  格式：“m:权限”
setfacl -m m:rx /project/

2 “mask”权限是用来限制ACL权限过大的。
   如果设置了“mask”权限为：rx
   即使所属组的权限为：rwx，但是它的最终权限要和“mask”相与，
   所以最终它的权限为：rx
___________________________________________________________
1 删除指定用户的ACL权限
setfacl -x u:用户名 文件名

2 删除指定用户组的ACL权限
setfacl -x g:用户名 文件名
   
3 删除文件的所有ACL权限
setfacl -b 文件名

___________________________________________________________
ACL权限默认与递归

1 递归ACL权限（它只是针对现有文件的ACL权限）
递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限
setfacl     -m      u:用户名:权限    -R      文件名


2 默认ACL权限（只对新建的文件有ACL权限）
默认ACL权限的作用是，如果给父目录设置了ACL权限，
那么父目录中的所有新建的文件都会继承父目录的ACL权限。
但是对以前建的文件没有ACL权限。
setfacl     -m      d:u:用户名:权限          文件名

### ===========================================================================ＳｅｔＵＩＤ
ＳｅｔＵＩＤ的功能：
1 只有可以执行的二进制程序才能设定SUID权限。
2 命令执行者要对该程序拥有X（执行）权限。
3 命令执行者在执行该程序时获得该程序文件属主身份（在执行程序的过程中灵魂附体为文件属主）
4 SetUID权限只有在程序执行过程中有效，也就是说身份改变只是在程序执行过程中有效。

passwd命令拥有SetUID权限，所以普通用户可以修改自己的密码。
ls -l /usr/bin/passwd
___________________________________________________________
1 设定SUID权限
“4”这个数字代表SUID
chmod 4755 文件名
chmod u+s 文件名

2 取消SUID的方法
chmod 755 文件名
chmod u-s 文件名 

___________________________________________________________
危险的SUID权限

1 关键目录应严格控制写权限。比如：“/“，”/usr“。。。
2 用户的密码设置要严格遵守密码三原则
3 对系统中默认应该具有SetUID权限的文件作一列表，
  定时检查有没有这之外的文件被设置了SetUID权限。


### ===========================================================================ＳｅｔＧＩＤ
ＳｅｔＧＩＤ针对文件的作用
1 只有可执行的二进制程序才能设置SGID权限。
2 命令执行者要对该程序拥有X（执行）权限。
3 命令在执行程序的时候，组身份升级为该程序文件属组
4 SetGID同样只在程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效。
_________________________________________________________________________
ls －l ／usr／bin／locate
1 ／usr／bin／locate是可执行二进制程序，可以赋予SGID权限的。
2 执行用户lamp对／usr／bin／locate命令拥有执行权限
3 执行／usr／bin／locate命令时，组身份会升级为slocate组，
而slocate组对／var／lib／mlocate／mlocate.db数据库拥有"r"权限，
所以普通用户可以使用locate命令查询mlocate.db数据库。
4 命令结束，lamp用户的组身份返回lamp组。

___________________________________________________________
ＳｅｔＧＩＤ针对目录的作用
1 普通用户必须对此目录拥有“r”和“x”权限，才能进入此目录。
2 普通用户在此目录中的有效组会变成此目录的属组。
3 若普通用户对此目录拥有“w”权限时，新建的文件的默认属组是这个目录的属组。


### ===========================================================================ＳｔｉｃｋｙＢＩＴ
SBIT粘着位作用

1 粘着位目前只针对目录有效
2 普通用户对该目录拥有“w”和“x”权限，即普通用户可以在此目录拥有写入权限
3 如果没有粘着位，因为普通用户拥有“w”权限，所以可以删除此目录下所有文件，
  包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有的文件，
  普通用户就算佣有了“w”权限，也只能删除自己建立的文件，但是不能删除其它
  用户建立的文件。
___________________________________________________________ 
# 添加粘着位  
chmod 1755 目录名
chmod o+t 目录名
# 删除粘着位 
chmod 755 目录名
chmod o-t 目录名

___________________________________________________________
SetUID，   4     Ｕ
SetGID，   2     Ｇ
StickyBIT，1     Ｏ
### ===========================================================================ＣＨＡＴＴＲ
文件系统属性chattr权限
1 chattr命令格式
chattr [+-=][选项] 文件或目录名
+       增加权限
-       删除权限
=       赋予权限
i选项，如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；
       如果结目录设置i属性，那么只能修改文件下的数据，但不允许建立和删除文件。
       
a选项，如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；
       如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。
___________________________________________________________
查看文件系统属性

lsattr 选项 文件名
－a 显示所有文件和目录
－d 若目标是目录，仅列出目录本身的属性，而不是子文件。

### ===========================================================================ＳＵＤＯ
sudo 是一种权限管理机制，
管理员可以授权于一些普通用户去执行一些 root 执行的操作，
而不需要知道 root 的密码	
___________________________________________________________

用户加入 sudo 组，您可以直接编辑 /etc/group 文件
 sudo vim /etc/group
在 sudo 组中加入新的用户，要使用逗号分隔多个用户。
或者您可以使用 usermod 命令把用户添加到一个组中：
 $ sudo usermod -a -G sudo jack
___________________________________________________________
sudo 命令的配置文件为   /etc/sudoers
who where whom command,说白了就是哪个用户在哪个主机以谁的身份执行那些命令，
那么这个 where, 是指允许在那台主机 ssh 连接进来才能执行后面的命令，
文件里面默认给 root 用户定义了一条规则：
root    ALL=(ALL:ALL)       ALL
root　　　　表示 root 用户。
ALL　　 　　表示从任何的主机上都可以执行，也可以这样 192.168.100.0/24。
(ALL:ALL) 　 是以谁的身份来执行，ALL:ALL 就代表 root 可以任何人的身份来执行命令。
ALL 　　　　表示任何命令。
那么整条规则就是 root 用户可以在任何主机以任何人的身份来执行所有的命令。
___________________________________________________________
再看个例子：
nick   192.168.10.0/24=(root) /usr/sbin/useradd
上面的配置只允许 nick 在 192.168.10.0/24 网段上连接主机并且以 root 权限执行 useradd 命令。
___________________________________________________________
现在我们可以回答 jack 为什么具有通过 root 权限执行命令的能力了。
打开 /etc/sudoers 文件：
sudo 组中的所有用户都具有通过 root 权限执行命令的能力！

