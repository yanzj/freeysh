### ===========================================================================ｄｅｃｌａｒｅ
declare [+/-][rxi][变量名称＝设置值] 或 declare -f

    +/-     "-"可用来指定变量的属性，"+"则是取消变量所设的属性。
    -f      仅显示函数。
    r       将变量设置为只读。
    x       指定的变量会成为环境变量，可供shell以外的程序来使用。
    i       [设置值]可以是数值，字符串或运算式。
### ===========================================================================ｅｘｐｏｒｔ
export [-fnp][变量名称]=[变量设置值]

    -f      代表[变量名称]中为函数名称。
    -n      删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
    -p      列出所有的shell赋予程序的环境变量 
export命令的功能跟 declare功能部分重合；export WWC="wangwenchao" 相当于 declare -x WWC="wangwenchao"; 
功能export -n WWC 相当于 declare +x WWC; 
功能export查看导出的环境变量

### ===========================================================================ｓｏｕｒｃｅ
作用:在当前bash环境下读取并执行FileName中的命令。
注：该命令通常用命令“.”来替代。
如：source .bash_rc 与 . .bash_rc 是等效的。
source命令与shell scripts的区别是，source在当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。
这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,
所以通过文件（命令列）设置环境变量时，要用source 命令。

### ===========================================================================ｎｏｈｕｐ
nohup 命令是 no hanp up 的缩写。
Unix/Linux下一般想让某个程序在后台运行，很多都是使用 & 在程序结尾来让程序自动运行；
但如果要想在退出终端后，程序依然还在后台运行，则要用 nohup与& 组合来实现。
nohup用法
nohup Command [ Arg ... ] [&]
nohup 命令运行由 Command参数和任何相关的Arg参数指定的命令，同时忽略所有的挂起 (SIGHUP) 信号，
或者修改用 -p 选项指定的进程来忽略所有的挂起 (SIGHUP) 信号(关闭终端、注销用户等，但是注意 ctrl + c 不是挂起信号)。
在注销后还可以使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &（表示“and”的符号）到命令的尾部。
输出将附加到当前目录的nohup.out 文件中。
    注： -p pid 和 Command 不能一起指定。
    使用 -p pid 时，指定进程的输出将不会重定向到 nohup.out。
    ctrl+c  nohup bash wwc.sh会停止运行，但是 bash wwc.sh & 会正常运行；
    直接关闭终端 nohup bash wwc.sh 会正常运行，bash wwc.sh & 会停止；
    所以要 nohup 跟 & 结合使用。
杀死由nohup执行的进程
    ps -ef | grep commond | grep -v grep  
    例如：
    ps -ef | grep "bash wwc.sh" | grep -v grep
    找到进程id
    kill -9 id   
### ===========================================================================ｔｙｐｅ
type命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。
用法
    -t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”；
    -p：如果给出的指令为外部指令，则显示其绝对路径；
    -a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。
结果
alias：别名。
keyword：关键字，Shell保留字。
function：函数，Shell函数。
builtin：内建命令，Shell内建命令。
file：文件，磁盘文件，外部命令。
unfound：没有找到。
### ===========================================================================ｓｅｔ
set     查询所有变量(包含系统环境变量)
env	    查询系统环境变量
export	设定环境变量（将会影响子进程）

alias                           # 查询命令别名
alias 别名="原命令"               # 设定命令别名
export PATH=$PATH:/opt/eclipse  # PATH变量叠加
vim ~/.bashrc                   # 写入此配置文件
___________________________________________________________
变量名只能包含数字、字母和下划线，
因为某些包含其他字符的变量有特殊含义，
这样的变量被称为特殊变量。
$0 ###当前脚本的文件名 (不带路经，带扩展名 .sh) xx.sh
$n      返回第n个参数。( n>0 );传递给脚本或函数的参数。
        n 是一个数字，表示第几个参数。
        例如，第一个参数是$1，第二个参数是$2。
$*      列出所有参数, "$*" 整体列出
$@      列出所有参数, "$@" 一一列出
$#      统计传入的变量个数 (e.g. ./xx.sh p1 p2)    输出2
___________________________________________________________
$* 和 $@ 的区别 

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，
都以"$1" "$2" … "$n" 的形式输出所有参数。但是当它们被双引号(" ")包含时，
"$*"    会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；
"$@"    会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。 

$? ###返回上一个命令执行的返回码
$$ ###表示当前Shell进程的ID，即pid.对于 Shell 脚本，就是这些脚本所在的进程ID。
$! ###最后运行的后台Process的pid
### ===========================================================================内建命令
内建命令和外部命令                               
内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，
这些命令由shell程序识别并在shell程序内部完成运行，
通常在linux系统加载运行时shell就被加载并驻留在系统内存中。
内部命令是写在bashy源码里面的，其执行速度比外部命令快，
因为解析内部命令shell不需要创建子进程。
比如：exit，history，cd，echo等。
有些命令是由于其必要性才内建的，例如cd用来改变目录，read会将来自用户（和文件）的输入数据传给Shell外亮。
另一种内建命令的存在则是为了效率，其中最典型的就是test命令，编写脚本时经常会用到它。另外还有I/O命令，
例如echo于printf.
### ===========================================================================外部命令
外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，
所以其包含的程序量也会很大，
在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。
通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。
shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。
外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin......等等。
可通过“echo $PATH”命令查看外部命令的存储路径，比如：ls、vi等。
外部命令就是由Shell副本（新的进程）所执行的命令，基本的过程如下：
    1 建立一个新的进程。此进程即为Shell的一个副本。
    2 在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。
      /bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin为PATH变量典型的默认值。
      当命令名称包含有斜杠（/）符号时，将略过路径查找步骤。      
    3 在新的进程里，以所找到的新程序取代执行中的Shell程序并执行。
    4 程序完成后，最初的Shell会接着从终端读取下一条命令，和执行脚本里的下一条命令。
用户在命令行输入命令后，一般情况下Shell会fork并exec该命令，但是Shell的内建命令例外，
执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程.
PS:为了实现强大的功能，有些内建命令也有了外部命令实现的版本，这些外部命令往往比对应的内部命令功能更强大，
但是相对效率可能会低（例如：cd、echo等）；同样一些外部命令为了执行效力的问题，
在内建命令中也有了实现（例如：printf）；如果一个命令既有内部实现又有外部实现，
直接使用使用的是其内部版本，要想使用其外部实现，可以使用绝对路径，
比如：echo是使用的其内部命令，/bin/echo是使用的其外部命令，查看一个外部命令的路径，可以使用 which 命令，
例如which echo


