### ===========================================================================
1. 首先我们将调试器与目标板以及计算机之间的线连接好->
  （此处默认调试器为st-link、对于其他调试器只要稍微更改OpenOCD的启动配置文件就可），
   并将st-link的接口设置到虚拟机上。随后我们通过OpenOCD指令连接调试器：

	openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg
	
	
	
### ===========================================================================
2. 在执行完此条指令后该终端就会一直执行OpenOCD的程序了，不要关闭它，我们再打开一个终端界面，
   进入我们的工程目录，比如我这里进入的就是我的libopencm3样例工程下的blink子工程目录

   然后我们使用指令输入调试文件并打开GDB程序->

	arm-none-eabi-gdb blink.elf 
	
	
	
### ===========================================================================	
3. 然后我们在GDB的指令界面中，输入连接指令，连接本地的3333端口->

	(gdb)target remote localhost:3333

   此时我们就将GDB与调试器接上了，运行OpenOCD的终端也会显示收到连接信息
   
   
   
### ===========================================================================  
4. 不过我们还没有完成所有的初始操作，此时我们需要输入指令来复位、停止MCU并加载elf文件

	(gdb)monitor reset
	(gdb)monitor halt 
	(gdb)load

  这里 monitor意为这向连接的外部软件发送指令，此处即向OpenOCD发送指令，
  因为reset halt等指令不是GDB的内部指令，而是OpenOCD的指令。
  随后的load指令会将启动时输入GDB的elf文件加载入MCU，即下载到MCU的flash。

到这里我们的所有GDB连接的初始操作就完成了，当然我们不仅可以使用OpenOCD启动调试端口，
st-link的驱动也也可以，使用指令：st-util就可以启动它，不过st-link驱动默认的端口是4242







### ===========================================================================
arm-none-eabi-gdb的调试指令


l	list指令的缩写，意为列出当前执行的源代码。
	同时输入指令后重复按回车等效于再次输入上次的指令 
c	continue的缩写，在嵌入式GDB中我们不能使用RUN指令来运行代码，
	相应的我们需要continue指令来运行。
s	step缩写，会进入子函数的单步运行
n	next缩写，即会跳过子函数的单步运行
u	until缩写使用时后方加行号如： u 16 即运行到第16行
finish	完成并跳出当前的子函数
p	print缩写，使用时后面加变量名称如：p tmp ，用来显示变量数值
display 使用时后面加变量名称如：display tmp ，用于跟踪变量数值，
	在每次执行停下时会自动显示变量数值。




b	break缩写，用于在程序中打断点，使用方式有很多种
b 16	在当前低16行代码出加断点。
b i=1	当i等于1时停止，类似于这种条件式断点的方式也是GDB独有的一种强大功能。
b main	在main函数的入口打断点。
i b	info break 缩写，显示当前设置的断点信息。
	如下面这个查到了在main函数处有两个断点，序号分别为1 和 2。


d break		delet break 缩写，删除所有断点
d break 1	删除序号为1的断点

bt		查看堆栈

q/Ctrl+d	使用q即quit指令或快捷键Ctrl+d来正常退出GDB


在GDB的指令窗口我们输入
(gdb)-		对就是一个 减号，然后回车我们来见证奇迹的时刻

