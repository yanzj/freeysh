### ===========================================================================
函数的调用语法

GNU make 函数的调用格式类似于变量的引用,以“$”开始表示一个引用。语法格式
如下:
	$(FUNCTION ARGUMENTS)
		或者:
	${FUNCTION ARGUMENTS}


1.调用语法格式中“FUNCTION”是需要调用的函数名,它应该是 make 内嵌的函
数名。对于用户自己的函数需要通过 make 的“call”函数来间接调用。

2.“ARGUMENTS”是函数的参数,参数和函数名之间使用若干个空格或者[tab]字
符分割(建议使用一个空格,这样不仅使在书写上比较直观,更重要的是当你不能
确定是否可以使用[Tab]的时候,避免不必要的麻烦);如果存在多个参数时,参数
之间使用逗号“,”分开。

3.以“$”开头,使用成对的圆括号或花括号把函数名和参数括起(在 Makefile
中,圆括号和花括号在任何地方必须成对出现)。
在 Makefile 中应该这样来书写     $(sort $(x))





### ===========================================================================
11 函数调用
	$(function arguments)

22 $(wildcard PATTERN)
	当前目录下匹配模式的文件
	例如：	src=$(wildcard *.c)

33 $(patsubst PATTERN,REPLACEMENT,TEXT)
	模式替换函数
	例如:	$(patsubst %.c,%.o,$src)
	等价于：$(src:.c=.o)

44 shell函数
	执行shell命令
	例如：	$(shell ls -d */)
	
	
### ===========================================================================
$(patsubst %.c,%.o,$(wildcard *.c))
首先使用“wildcard”函数获取工作目录下的.c 文件列表;之后将列表中所有文件名的后缀.c 替换为.o

objects := $(patsubst %.c,%.o,$(wildcard *.c))
这里我们使用了 make 的隐含规则来编译.c 的源文件。对变量的赋值也用到了一个特殊的符号(:=)。


$(patsubst %.c,%.o,$(src))
patsubst把$(file)中的变量符合后缀是.c的全部替换成.o，
任何输出。
或者可以使用
obj=$(file:%.c=%.o)
效果也是一样的。


find ./ -name "*.o" -exec rm {} \;



### ===========================================================================
TOP=$(shell readlink -f "$(dir $(lastword $(MAKEFILE_LIST)))")
功能： 返回（最近的）Makefile 真实绝对的路径 
讲解：
首先$(MAKEFILE_LIST) 会返回最近使用的Makefile文件
（如果使用了include 包含了一个Makefile文件那么返回就是这个被include 包含的Makefile文件的路径，
如果没有使用include 那么返回的是正在使用的Makefile文件所在的绝对路径）

lastword这个函数表示提取最后一个MAKEFILE_LIST列表里的最后一个元素。
元素与元素之间是以空格符分开。 $(lastword $(MAKEFILE_LIST)) 表示提取最后一个Makefile
从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。
最后使用readlink -f 返回绝对路径
$(readlink -f .)	获得当前目录的真实路径
$(readlink -f ../..	获得上上一级目录的真实路径
