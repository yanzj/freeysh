### ===========================================================================
### 变量 
1 变量定主的两种形式：
    递归展开方式     VAR = var
    简单方式        VAR := var

2 简单变量 
    定义：		变量名 := [文本]
    添加：		变量名 += [文本]

3 变量引用 
    $(变量名)
    ${变量名}
    $单字符变量名



### ===========================================================================
### 赋值 

=      是最基本的赋值
:=     是覆盖之前的值
?=     是如果没有被赋值过就赋予等号后面的值
+=     是添加等号后面的值 

1、“=”
“=”表示make会将整个makefile展开后，再决定变量的值。
也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：

            x = foo
            y = $(x) bar
            x = xyz
在上例中，y的值将会是 xyz bar ，而不是 foo bar 。


2、“:=”
“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。

            x := foo
            y := $(x) bar
            x := xyz

在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。


3 用 ?= 定义变量
  foo ?= bar
含义是，如果foo没有被定义过，那么变量foo的值就是 "bar",
        如果foo被定义过，那么这条语句什么也不做。
其等价于：
ifeq(($origin foo),undefined)
foo = bar
endif



### ===========================================================================
### 自动变量 

$* 不包含扩展名的目标文件名称
$+ 所有的依赖文件，以空格分开，
   并以出现的先后为序，可能包含重复的依赖文件
$< 第一个依赖的文件名称
$? 所有时间戳比目标文件晚的依赖文件，并以空格分开
$@ 目标文件的完整文件名称
$^ 所有不重复的依赖文件，以空格分开
$% 如果目标是归档文件，则该变量表示目标的归档成员名称。

OBJS=add.o sub.o
CC=gcc
CFLAGS=-Wall -O -g
main: $(OBJS)
	$(CC) $^ -o $@
add.o: add.c add.h
	$(CC) $(CFLAGS) -c $< -o $@
sub.o: sub.c sub.h
	$(CC) $(CFLAGS) -c $< -o $@




### ===========================================================================
在使用 make 的递归调用时,在 Makefile 规则的命令行中应该使用变量“MAKE”来
代替直接使用“make”。上一小节的例子应该这样来书写:

subsystem:
	cd subdir && $(MAKE)

变量“MAKE”的值是“make”。如果其值为“/bin/make”那么上边规则的命令就为“cd
subdir && /bin/make”。这样做的好处是:当我们使用一个其它版本的 make 程序时,
可以保证最上层使用的 make 程序和其子目录下执行的 make 程序保持一致。




### ===========================================================================
一般搜索(变量 VPATH)

定义变量“VPATH”时,使用空格或者冒号(:)将多个需要搜索的目录分开
VPATH = src:../headers
这样我们就为所有规则的依赖指定了两个搜索目录,“src”和“../headers”




### ===========================================================================
选择性搜索(关键字 vpath)

vpath PATTERN DIRECTORIES
为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES”。
多个目录使用空格或者冒号(:)分开。类似上一小节的“VPATH”变量。

vapth 使用方法中的“PATTERN”需要包含模式字符“%”。“%”意思是匹配一个或者
多个字符,例如,“%




### ===========================================================================
递归展开式变量 =

第一种风格的变量是递归方式扩展的变量。这一类型变量的定义是通过“=”或者使
用指示符“define” 定义的。这种变量的引用,在引用的地方是严格的文本替换过程,
此变量值的字符串原模原样的出现在引用它的地方。

这种类型变量在定义时,可以引用其它的之前没有定义的变量(可能在后续部分定义,
或者是通过 make 的命令行选项传递的变量)。看一个这样的例子:

CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar

“CFLAGS”会在命令中被展开为“-Ifoo -Ibar -O”。而在“CFLAGS”的定义中使用了其
后才定义的变量“include_dirs”。


其缺点是:
使用此风格的变量定义,可能会由于出现变量的递归定义而导致 make 陷入到
无限的变量展开过程中,最终使 make 执行失败。例如,接上边的例子,我们给这
个变量追加值:
CFLAGS = $(CFLAGS) –O
它将会导致 make 对变量“CFLAGS”的无限展过程中去(这种定义就是变量的递归定义)。
因为一旦后续同样存在对“CLFAGS”定义的追加,展开过程将是套嵌的、不能终止的(在
发生这种情况时,make 会提示错误信息并结束)
第二个缺点:这种风格的变量定义中如果使用了函数,那么包含在变量值中
的函数总会在变量被引用的地方执行(变量被展开时)。


### ===========================================================================
直接展开式变量 :=

为了避免“递归展开式”变量存在的问题和不方便。GNU make 支持另外一种风格的
变量,称为“直接展开”式。这种风格的变量使用“:=”定义。
在使用“:=”定义变量时,
变量值中对其他量或者函数的引用在定义变量时被展开(对变量进行替换)。所以变量被
定义后就是一个实际需要的文本串,其中不再包含任何变量的引用



### ===========================================================================
追加变量值 +=

通常,一个通用变量在定义之后的其他一个地方,可以对其值进行追加。这是非常
有用的。我们可以在定义时(也可以不定义而直接追加)给它赋一个基本值,后续根据需
要可随时对它的值进行追加(增加它的值)。在 Makefile 中使用“+=”(追加方式)来实
现对一个变量值的追加操作。像下边那样:
objects += another.o



1.如果被追加值的变量之前没有定义,那么,“+=”会自动变成“=”,此变量就
被定义为一个递归展开式的变量。如果之前存在这个变量定义,那么“+=”就继承
之前定义时的变量风格。

2.直接展开式变量的追加过程:变量使用“:=”定义,之后“+=”操作将会首先
替换展开之前此变量的值,尔后在末尾添加需要追加的值,并使用“:=”重新给此
变量赋值。实际的过程像下边那样:
variable := value
variable += more
就是:
variable := value
variable := $(variable) more


3.递归展开式变量的追加过程:一个变量使用“=”定义,之后“+=”操作时不
对之前此变量值中的任何引用进行替换展开,而是按照文本的扩展方式(之前等号
右边的文本未发生变化)替换,尔后在末尾添加需要追加的值,并使用“=”给此
变量重新赋值。实际的过程和上边的相类似:
variable = value
variable += more
相当于:
temp = value
variable = $(temp) more
当然了,上边的过程并不会存在中间变量:“temp”,使用它的目的时方便描述。这种情
况时如果“value”中存在某种引用,情况就有些不同了




### ===========================================================================
### GNU-MAKE命令变量/GNU-MAKE 命令参数的变量 

AR          函数库打包程序,可创建静态库.a 文档,默认是“ar”。
ARFLAGS     执行“AR”命令的命令行参数。默认值是“rv”。
AS          汇编程序默认是“as”。
ASFLAGS     执行汇编语器“AS”的命令行参数(明确指定“.s”或“.S”文件时)。
CC          C 编译程序。,默认是“cc”。
CFLAGS      执行“CC”编译器的命令行参数(编译.c 源文件的选项)。
CPP         C 程序的预处理器(输出是标准输出设备),默认是“$(CC) -E”。
CPPFLAGS    执行 C 预处理器“cc -E”的命令行参数(C和 Fortran编译器会用到)
LD
LDFLAGS     链接器(如:“ld”)参数。
RM          删除命令,默认是“rm -f”。
### ===========================================================================

