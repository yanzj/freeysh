### ===========================================================================
顺序表的插入
插入(insert) : 在表中添加一个新结点。
1    指定条件插入(比如,有序插入)
2    指定位置插入(插在表头、表尾、第i个位置)
3    无条件插入(随便插在何处)

简单插入(指定位置)
for(j=n-1; j>=i; j--) a[j+1]=a[j]; //右移,空出a[i]
a[i]=x; //插入x
n++; //表长增1

插入a[i]共需要移动n-i个元素
T 插入 (n)=n-i



### ===========================================================================
简单删除(指定位置)
删除:删除表中某个结点。
删除方式有:
1 指定特征的删除:删除值为x的结点。
2 按指定位置删除:比如,删除表头结点,或表尾结点,或第i个结点。

for(j=i; j<n-1; j++) a[j]=a[j+1]; //左移,抹去a[i]
n--; //表长减1

共移动n-1-i个元素



### ===========================================================================
指定位置插/删效率分析
T 插入 (n)=n-i                    T 删除 (n)=n-1-i

(1)在表尾处插/删,最好,T(n)=O(1)
(2)在表头处插/删,最坏情况,T(n)=O(n)
(3)平均情况,移动半数表元素 ,T(n)=O(n)
(4)适于下列情况之一:
    表长不大
    不做,或很少做插/删
    只在表的端点处插/删





### ===========================================================================
查找(search),给定结点的关键字值(以下简称结点值)x,查找值等于x的结点的存储地址。

1 按关键字x查
查找结果:成功,返回x的地址
不成功,返回无效地址

2 按非关键字查
查找结果:可能找出多个符合条件的结点


### ===========================================================================
顺序查找
在a[0]至a[n-1]中,查找值为x的结点的程序段

(1)从左向右查:
for (i = 0; i < n; i++)
    if (a[i] == x)
        return i;
    return -1;//表示没找到


(2)从右向左查:
for (i = n-1; i >= 0; i--)
    if (a[i] == x)
        return i;
    return -1;






### ===========================================================================
顺序查找(带监督元)
在查找终点预留一个空白结点(监督元)
分配空间a[n+1]

1 监督元在表头a[0]处,从右向左查
2 监督元在表头a[n]处,从左向右查


### ===========================================================================
顺序查找 (带监督元)
带表头监督元的顺序查找算法:
int SQsearch(int a[], int x, int n)
{ 
    int i;
    1. i=n; //查找起点
    2. a[0]=x; //预置监督元
    3. while(a[i]!=x)
         i--; //从右向左查
    4. return i ;
}

顺序查找 (带监督元)
只牺牲一个存储结点,便可将查找效率提高近一倍,这在表长n较大、查找频繁的情况下,是很“合算”的。
这种“以空间换取时间”的做法用得好的话往往能够产生奇效。
需要说明的是,虽然查找速度提高了一倍,
但时间复杂性的阶不变,仍是O(n),只是时间复杂性函数的常系数变减小了。



### ===========================================================================
二分查找

二分查找核心思想
1、计算中值位置
2、缩小查找区间

left表示起点,right表示终点,mid表示中值点,数组a存放元素,x为带查找元素。
1. 计算中值点:
    mid=(left+right)/2;
    
2. 若x=a[mid],查找成功,返回mid,结束;

2.1 若x<a[mid],则往左缩小查找区间,
    重复上述过程;
否则    
2.2 若x>a[mid],则往右缩小查找区间
    重复上述过程

int binary_search(int a[],int x, int left, int right)
{ 
    int mid;
    mid=(left + right)/2;
    if(x == a[mid]) return mid;
    if(x < a[mid])
        return binary_search(a, x, left, mid-1 );
    else
        return binary_search(a, x, mid+1, right );
}




int binary_search(int a[],int x,int left,int right)
{ 
    int mid;
    if(left>right) return –1; //查找失败
    mid=(left+right)/2;
    if(x==a[mid]) return mid;//查找到,返回
    if(x<a[mid])
        return binary_search(a,x,left,mid-1);//左端查找
    return binary_search(a,x,mid+1,right);//右端查找
}




int binary_search(int a[],int n,int x)
{ 
    int left,right,mid;
    left=0;right=n-1; //确定查找段的起点和终点
    while(left<=right)
    {
        mid=(left+right)/2;
        if(x==a[mid]) return mid; //查找到,返回
        if(x<a[mid]) right=mid-1; //左端查找
        else left=mid+1; //右端查找
    }
    return -1;
}




### ===========================================================================
分而治之——分治法
    将一个难以直接解决的大问题,分割
    成一些规模较小的、性质相同的子问题,
    以便各个击破,分而治之。



