#############################################

ARM指令集
=========

Thumb-2 技术引入了 Thumb指令集的一个新的超集，
可以在一种模式下同时使用16位和32位指令集。

ARM指令集格式
=============

<opcode>{<cond>}{S} <Rd>, <Rn> {,<operand2>}
1 <opcode>  操作码
2 {<cond>}  决定指令执行的条件域
3 {S}       决定指令执行是否影响状态寄存器xPSR的值
4 <Rd>      目的寄存器
5 <Rn>      第一个操作数为寄存器
6 <operand2>第二个操作数
ARM指令语法格式中，<>中的内容是必须的，{}中的内容是可选的

CMP R0, R1
BEQ AAA
...
AAA
说明：如果R0==R1,则跳转到AAA标号处执行。

ARM寻址方式
==========

1 数据处理寻址方式
  1.立即数寻址方式
立即寻址指令中的操作码字段后面的地址码部分是操作数本身
即数据就包含在指令当中，取出了指令也就取出了可以立即使
用的操作数（这样的数称为立即数）

立即数可表示为常数表达式。
在立即数寻址方式中，规定这个立即数必须是一个8bit的常数
通过循环右移偶数位得到。
ARM 只提供了12bit 来放数据，其中8位来记录数值的，
另外4位来放移位的位数，以此来形成一个立即数。

MOV R0, #0x800
立即数以“#”开头，16进制在#后面加“0x”或“&”表示。

  2.寄存器寻址方式
Rm-----寄存器方式。在寄存器方式下，操作数即为寄存器的数值。
操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，
指令执行时直接取出寄存器的值来操作。

MOV R1, R2     ;r1==r2
SUB R0, R1, R2 ;r0==r1-r2
注意：第一个是目的寄存器，然后是第一个操作数寄存器，
      最后是第二个操作数寄存器。

  3.寄存器移位寻址方式
寄存器移位寻址是ARM指令集持有的寻址方式。
当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作
数结合之前，选择进行的移位操作。

MOV R0, R2, LSL #3      ;R2的值左移3位，结果放入R0
ANDS R1, R1, R2, LSL R3 ;R2的值左移R3位，与R1 相与，结果放入R1中


普通Load/Store指令的寻址方式
=========================

语法格式：
LDR|STR{<cond>}{B}{T} <Rd>, <addressing_mode>
注：B为加载字节数据，T为可选后缀。
若指令有T，那么处理器在持权模式下，存储系统也将
访问看成在用户模式下进行的。
T 在用户模式下无效。

杂类Load/Store指令的寻址方式
=========================

LDR|STR{<cond>}H|SH|SB|D <Rd>, <addressing_mode>
注：B为字节，H为半字，D为双字，S为加载有符号数。

批量Load/Store指令寻址
====================

批量Load/Store指令将一片连续的内存单元的数据加载到通用寄存器组中，
或者将一组通用寄存器的数据存储到内存单元中。

它的寻址模式产生一个内存单元的地址范围，指令寄存器和内存单元
在对应关系满足这样的规则：编号低在寄存器对应于内存中低地址单元，
编号高的寄存器对应内存中地址高的单元。

LDM|STM{<cond>}<addressing_mode> <Rn> {!}, <registers><^>


协处理器指令寻址方式
=================


堆栈操作寻址方式
==============

1 满堆栈，堆栈指针指向栈顶元素
2 空堆栈，堆栈指针指向第1个可用元素
3 递减栈，堆栈向内存地址减小的方向生长
4 递增栈，堆栈向内存地址增加的方向生长

1 FD(Full Descending)
2 ED(Empty Descending)
3 FA(Full Ascending)
4 EA(Empty Ascending)


######################################################

ARM汇编语言伪指令
================

伪指令------>指示性语句	》汇编器处理
指令-------->指令性语句 》处理器执行
指令有相应的操作码，而伪指令没有

1 数据定义伪指令
==============
1.字节单元定义伪指令 DCB
格式：标号 DCB 表达式
功能：DCB伪指令用分配一片连续的字节存储单元，
      并用伪指令指定的表达式初始化。
注意：表达式可以为 0～255 的数字或字符串。
      DCB也可能用 “=”代替。
例如：
	str DCB "this is a test!" ;分配连续的字节存储单元
                                  ;并初始化

2 半字单元定义伪指令 DCW （或DCWU）
格式：标号 DCW （或DCWU） 表达式
功能：DCW(或DCWU）伪指令用于分配一片连续的半字单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为和序标号或数字表达式。
      用DCW分配的存储单元是半字对齐的，
      而用DCWU 分配的存储单元并不严格半字对齐。
例如：
	data_test DCW 1, 2, 3,  ;分配连续的半字存储单元
                                ;并初始化

3 字单元定义伪指令 DCD （或DCDU)
格式：标号 DCD(或DCDU) 表达式
功能：DCD（或DCDU)伪指令作于分配一片连续的字存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      DCD也可以用 “&” 代替。
      作DCD分配的存储单元是字对齐的，
      而用DCDU分配的存储单元并不严格字对齐。
例如：
	datatest DCD 2, 1, 5  ;分配连续的字存储单元
                              ;并初始化

4 双精度定义伪指令DCFD(或DCFDU)
格式：标号 DCFD(或DCFDU) 表达式
功能：DCFD(或DCFDU) 伪指令用于双精度浮点数
      分配一片连续的存储单元并用伪指令中指定的表达式初始化。
      每个双精度浮点数占用 2个字存储单元。
注意：用DCFD分配的存储单元是字对齐的，
      而用DCFDU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCFD 3E15, -4E2 ;分配连续的字存储单元
                                  ;并初始化为指定的双精度

5 单精度数定义伪指令 DCFS(或DCFSU)
格式：标号 DCFS(或DCFSU) 表达式
功能：DCFS(或DCFSU) 伪指令用于为单精度浮点数
      分配一片连续的字存储单元并用伪指令指定的表达式初始化。
注意:每个单精度浮点数占用 1个字单元。
     用DCFS分配的存储单元是字对齐的，
     而用DCFSU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCSD 3E15, -4E2 ;分配连续的字存储单元
                                  ;并初始化为指定的单精度数      

6 双字单元定义伪指令 DCQ （或DCQU)
格式：标号 DCQ(或DCQU) 表达式
功能：DCQ(或DCQU)伪指令作于分配一片以 8 个字节为单位的连续存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      作DCQ分配的存储单元是字对齐的，
      而用DCQU分配的存储单元并不严格字对齐。
例如：
	datatest DCQ 226      ;分配连续的字存储单元
                              ;并初始化指定的值

7 存储区域定义伪指令
格式：标号 SPACE 表达式
功能：SPACE 伪指令用于分配一片连续的存储区域并初始化为 0。
注意：表达式在分配的字节数。
      SPACE也可以用 “%” 代替。
例如：
	datetest SPACE 256 ;分配连续256个字节的存储单元
                           ;并初始化为 0

8 首在址定义伪指令
格式：MAP 表达式{，基地址寄存器}
功能：MAP伪指令用于定义一个结构的内存表的首地址
      MAP也可以用 “^”代替
注意：表达式可以为程序中的标号或数学表达式，
      基地址寄存器为可选项
      当基地址寄存器不存在时表达式的值即为内存表的首地址
      当该项存在时，内存表的首地址为表达式的值与基址寄存器的和
      MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。
例如：
	MAP 0x100, R0 ;定义结构化内存表首地址为
                      ;0x100+R0

9 数据定义伪指令 FIELD
格式：标号 表达式
功能：用于定义结构化内存表中数据的域，
      也可以用 “#”代替
      值为当前数据域在内存表中所占的字节数
注意：该常与 MAP伪指令配合使用定义结构化的内存表
      MAP伪指令定义内存表的首地址，
      FIELD伪指令定义内存表中的各个数据域，
      并可以为每一个数据域指定一个标号供其它的指令引用
      此外两个伪指令仅定义数据结构，并不实际分配存储单元。
例如：
MAP 0x100  ;定义结构化内存表的首地址0x100
A FIELD 8  ;定义A长度为8字节，位置为0x100
B FIELD 16 ;定义B长度为16字节，位置为0x108
C FIELD 32 ;定义C长度为32字节，位置为0x118


2 符号定义伪指令(Symbol Definition)
================================

1 全局变量定义伪指令
格式：GBLA GBLL GBLS 全局变量名
功能：GBLA伪指令用于定义一个全局数字变量，初始化为 0
      GBLL伪指令用于定义一个全局逻辑变量，初始化为 F（假）
      GBLS伪指令用于定义一个全局的字符串变量，初始化为 空
注意：由于这三条伪指令用于定义全局变量，因此整个程序范围内变量名必须唯一。
例如：
	GBLA Test1 ;定义一个全局数字变量，名为Test1
	GBLL Test2 ;定义一个全局逻辑变量，名为Test2
	GBLS Test3 ;定义一个全局字符串变量，名为Test3
2 局部变量定义伪指令 LCLA,LCll,LCLS
格式：LCLA(LCLL,LCLS) 局部变量名

3.变量赋值伪指令 SETA,SETL,SETS
例如：
	LCLA test7		;声明一个局部数字变量，变量名为test7
	test7 SETA 0x1234	;将该变量赋值为0x1234
	LCLL test8		;声明一个局部逻辑变量，变量名为test8
	stest8 SETL {TRUE}	;将变量赋值为真

4 寄存器列表定义伪指令 RLIST
格式：名称 RLIST {寄存器列表}
功能：RLIST 伪指令可用于对一个通用寄存器列表定义名称，
      使用该伪指令定义的名称可以在ARM指令 LDM/STM中使用
注意：在LDM/STM指令中，列表中的寄存器访问次序为根据
      寄存器的编号由低到高，而与列表寄存器排列无关。
例如：
RegList RLIST {R0-R5,R8,R10} ;将寄存器列表名称定义为RegList，
                             ;可以在ARM指令LDM/STM中通过该名称访问寄存器列表


3 汇编结构（Assembly Structure)伪指令
==================================
1 段定义伪指令 AREA
格式：AREA 段名 属性1, 属性2, ......
功能：AREA伪指令用于定义一个代码段或数据段，
      其中，段名若以数字开头，则该段名需要用 “|“括起来
      例如：|1_test|
注意：一个汇编程序至少包含一个段，
     当程序太长时，也可以将程序分为多个代码段或数据段。

属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。

CODE 属性：用于定义代码段，默认为 READONLY
DATA 属性：用于定义数据段，默认为 READWRITE
READONLY 属性：指定本段为只读，代码段默认为 READONLY
READWRITE 属性：指定本段可读可写，义数据段默认为 READWRITE
ALIGN 属性：使用方式为 ALIGN表达式。
            在默认时，ELF(可执行连接文件）的代码段和数据段是按字对齐的。
            表达式的取值范围为 0～31 ，相应的对齐方式为 2表达式次方。
COMMON 属性：该属性定义一个通用的段，不包含任何的用户代码和数据。
            各源文件中同名的 COMMON段共享同一段存储单元。

ALIGN 伪指令
格式：ALIGN {表达式{，偏移量}}
功能：ALIGN伪指令可以通过添加填充字节的方式，使当前位置满足一定的对齐方式。
      其中，表达式的值用于指定对齐方式，可能取值为 2 的幂，如1,2,4,8,16等。
      若未指定表达式，则将当前位置对齐到下一个字的位置。
      偏移量也为一个表达式，若使用该字段，则当前位置的对齐方式为：
            2 的表达式次幂 + 偏移量。
例如：
	AREA Init, CODE, READONLY, ALIGN=3
        ;指定后面的指令为 8 字节对齐方式。

3 程序入口伪指令 ENTRY
格式：ENTRY
功能：ENTRY 伪指令用于指定汇编程序的入口点。
注意：在一个完整的汇编程序中至少有一个 ENTRY,
      当有多个 ENTRY时，程序的真正入口点由链接器指定。
      但在一个源文件中最多只能有一个ENTRY,也可以没有。
例如：
	AREA Init, CODE, READONLY
	ENTRY	;指定程序的入口点

4 程序结束伪指令 END
格式：END
功能：END用于通知编译器已经到了源程序的结尾。

5 标号输出伪指令 EXPORT(或GLOBAL)
格式：EXPORT 标号 {[WEAK]}
功能：EXPORT伪指令用于在程序中声明一个全局的标号，
      该标号可以在其它文件中引用。
注意：EXPORT可以用GLOBAL代替，标号在程序中区分大小写。
      WEAK 选项，声明其它同名标号优先于该标号被引
例如：
AREA Init, CODE, READONLY
EXPORT Main0 ;声明一个全局引用的标号Main0

6 标号输入伪指令 IMPORT
格式：IMPORT 标号 {[WEAK]}
功能：IMPORT伪指令用于通知编译器要使用的标号在其它源文件中的定义，
      但要在当前源文件中引用，且无论当前源文件是否引用该标号，
      该标号均会被加入到当前源文件的符号表中。
注意：标号在程序中区分大小写，
      WEAK 选项，表示当所有的源文件都没有定义这样一个标号时，
      编译器也不会给出错误信息。
在多数情况下将该标号置为0,若该标号为 B或BL指令引用，
则将B或BL指令置为 NOP操作。

例如：
AREA Init, CODE, READONLY
IMPORT Main1 ;通知编译器当前文件在引用标号Main1,
             ;但Main1在其它源文件中定义。

7 标号引入伪指令 EXTERN
格式：EXTERN 标号 {[WEAK]} 
功能：EXTERN伪指令用于通知编译器在使用的标号在其它的源文件中定义，
      但要在当前源文件中引用，
      与IMPORT 不同的是
      如果当前源文件实际并未引用该标号，
      该标号就不会加入到当前源文件的符号表中。

8 源文件包含伪指令 GET(或INCLUDE)

9 目标文件包含伪指令 INCBIN

10 汇编控制伪指令
=================
1.1 条件控制伪指令 IF, ELSE, ENDIF
    格式：
IF 逻辑表达式
	指令序列1
ELSE 
	指令序列2
ENDIF

功能：该指令能根据条件的成立与否决定是否执行某个指令序列。
      当IF后面的逻辑表达式为真，
      则执行指令序列1,
      否则执行指令序列2

1.2 循环控制伪指令 WHILE, WEND
格式：
WHILE 逻辑表达式
	指令序列
WEND
功能：该组伪指令能根据条件的成立与否决定是否循环执行某个指序列。
      当WHILE后面的逻辑表达式为真，则执行指令序列，
      该指令序列执行完毕后，再判断逻辑表达式的值，
      若为真则继续执行，一直到逻辑表达式的值为假。

1.3 宏定义伪指令 MACRO, MEND =================
格式：
MACRO 
	$标号 宏名 $参数1, $参数2, ...
	指令序列
MEND

功能：MACRO，MEND,伪指令可以将一段代码定义为一个整体，称为宏。
      然后可以通过宏指令多次调用该段代码。
注意：$标号在宏指令展开时，标号会替换为用户定义的符号。
      宏指令可以使使用一个或多个参数，
      当宏指令被展开时，这些参数被相应的值替换。
说明：宏指令的使用方式和功能与子程序有些相似，
      子程序可以提供模块化的程序设计，节省存储空间并提高运行速度。
      但在使用子程序结构时需要保护现场，从而增加了系统的开销。
      因此，在代码较短 且需要传递参数较多时，可以使用宏指令代替子程序。

包含在MACRO和MEND 之间的指令序列称为宏定义体。
在宏定义体的第一行应该声明宏的原型（包含宏名，所需的参数），
然后就可以在汇编程序中通过宏名来调用该指令序列。

1.4 宏退出伪指令 MEXIT
格式：MEXIT
功能：MEXIT用于从宏定义中退出去。

其它常用伪指令
=============
1.等效定义伪指令 EQU
格式：名称 EQU 表达式{，类型}
功能：EQU伪指令用于为程序中的常量，标号等定义一个等效的字符名称。
      类似于C语言中的 #define .
      其中EQU可以用”*“代替。
注意：名称EQU伪指令定义的字符名称，
      当表达式为 32位常量时，可指定表达式的数据类型，
       以下有 3 种数据类型：
       CODE16, CODE32,DATA.
例如：
Test EQU 10		;定义标号Test的值为10
addr EQU 0xff,CODE32    ;定义Addr的值为0xff，且
                        ;该处为32位的ARM指令。

2 别名定义伪指令 RN
格式：名称 RN 表达式
功能：RN 伪指令用于给一个寄存器定义一个别名。
注意：采用这种方式可以方便程序员记忆寄存器的功能。
      其中，名称为给寄存器定义的别名，
      表达式为寄存器的编码。
例如：
Temp RN R0
;将R0定义一个别名为Temp.

ROUT伪指令
格式：{名称} ROUT
功能：用于给一个局部变量定义作用范围。
注意：在程序中未使用该伪指令时，
      局部变量的作用范围为所在的AREA,
      而使用ROUT伪指令后，
      局部变量的作用范围为当前 ROUT和下一个ROUT 之间。













#######################################################

ARM与Thumb汇编语言的语句格式：
{标号} {指令或伪指令} {;注释}

注意：每一条指令的助记符都可以大写，或者全部小写，但不可以
在一条指令中大小写混用。

另外，若一条语句太长，可将分为若干行来书写，在行末用续行符 “\”
表示下一行与本行为同一条语句。

1 符号常量
	数字型
	逻辑型
	字符串型
2 符号变量
	数字型
	逻辑型
	字符串型
3 全局变量
	GBLA
	GBLL
	GBLS
4 局部变量
	LCLA
	LCLL
	LCLS
5 变量初始化
	SETA
	SETL
	SETS

#########################################

汇编语言的程序结构
=================
ARM有两种段，代码段和数据段

汇编语言的源程序文件名后缀为 .s;
程序以段为单位组织代码，可以分为数据段和代码段。
代码段内的内容为程序执行的代码，
数据段存放代码运行时需要用到的数据。

一个汇编语言至少有一个代码段，当程序较长时，
可以分割为多个代码段和数据段，多个段在程编译链接时最终形成一个可执行的映像文件。
链接器根据系统默认或用户设置的规则，将各个段安排在存储器相应的位置。

因此源程序中段之间的相对位置与可执行的映像文件中段的位置一般不会相同。

1 可执行映像文件通常由以下几部分组成：
  一个或多个代码段，代码段的属性为只读。
  零个或多个包含初始化数据的数据段，数据段的属性为可读写。
  零个或多个不包含初始化数据的数据段，数据段的属性为可读写。

2 在汇编语言程序中，用 AREA 伪指令定义段，并说明定义段的相关属性。
  用 ENTRY 伪指令标识程序的入口点。
  接下来为指令序列，
  程序的末尾为 END 伪指令，该伪指令告诉编译器源文件的结束。

3 每一个汇编程序段都必须有一条 END伪指令，指示程序段的结束。


子程序调用
===============

1 在ARM汇编语言程序中，子程序的调用一般是通过 BL 指令来实现的。
  使用格式：
	BL 子程序名

2 运行时，将子和序的返回地址放在连接寄存器 LR中，
  同时将珵序计数器PC 指向子程序入口点，
  当子程序执行完毕需要返回调用处时，
  只需要将 LR中的返回地址重新拷贝给程序计数器PC 即可。

3 在调用子程序的同时，也可以完成参数的传递和从子程序返回运算的结果，
  通常可以使用寄存器 R0~R3完成。

AREA Init, CODE, READONLY
ENTRY
Start
	LDR R0, =0x3FF5000
	LDR R1, 0xFF
	STR R1, [R0]
	LDR R0,  =0x3FF5008
	LDR R1, 0x01
	STR R1, [R0]
	BL Next
	......
	Next
	......
		MOV PC, LR
END












