### ==================================================
ATPCS
嵌入式 C 语言编程， AAPCS规则
通常需要将汇编程序以文件的形式加入项目当中，
并通过 ARM体系结构程序调用标准：
(Procedure Call Standard for the ARM Architecture, AAPCS)
的规定与 C程序相互调用与访问。



为了使单独编译的 C语言程序和汇编程序之间能够相互调用，
必须为子程序之间的调用规定一定的规则。            AAPCS
=======================================================
基本的AAPCS规定了在子程序调用的一些基本规则，包括下面3个方面：
1 寄存器的使用规则及其相应名称。
============================
R0~R3
子程序通过寄存器 R0~R3来传递参数，这时寄存器R0~R3可以记作A1-A4
被调用的子程序在返回前无需恢复寄存器R0~R3的内容。

R4~R11
在子程序中，使用寄存器R4~R11来保存局部变量。
这时寄存器R4~R11可以记作V1-V8

R12
寄存器R12用作过程调用时的临时寄存器
(用于保存SP, 在函数返回时使用该寄存器出栈)，记作IP。

R13
寄存器R13用作数据栈指针，记作SP.
在子程序中寄存器R13 不能用作其它用途。

R14
寄存器R14称为连接寄存器，记作LR。
它用于保存子程序的返回地址。

R15
寄存器R15是程序计数器，记作PC




2 数据栈的使用规则。
==================
AAPCS规定堆栈为FD类型，即满递减堆栈，
并且堆栈的操作是 8 字节对齐。

而对于汇编程序来说，如果目标文件包含了名部调用，
则必须满足以下条件：
	1 外部接口的数据栈一定是 8位对齐的，
	  也就是保证在进入该汇编代码后，直到该
	  汇编程序调用外部代码之间，数据栈的
	  栈指针变化为偶数个字。
	2 在汇编程序中使用 PRESERVE8伪指令操作
	  告连接器，本汇编程序是8字节对齐的。

3 参数传递的规则。
=================
对于参数个数可变的子程序，当参数不超过
4个时，可以使用寄存器 R0~R3来进行参数传递，
当参数超过4个时，还可以使数据栈来传递参数。

在参数传递时，将所有参数看做是存放在连续的内存单元中的字数据。
然后，依次将各字数据传送到寄存器R0,R1,R2,R3中，
如果参数个数多于4个，将剩余的字数据传送到数据栈中。

入栈的顺序与参数顺序相反，即最后一个字数据先入栈。


4 数据栈限制检查
================
如果在程序设计期间能够准确在计算出所需的内存总量，
就不需要进行数据栈的检查，但是通常情况下这是很难做到的，
这时需要进行数据栈的检查。

在进行数据栈的检查时，使用寄器R10作为数据栈限制指针，
这时R10又记作SL,用户在程序中有能控制该寄存器。

在已经占有栈的最低地址和SL之间必须有256字节的空间。
也就是说，SL所指的内存地址必须比已经占用的栈的最低地址低256个字节。

当中断处理程序使用用户的数据栈时，在已经占用的栈的最低地址和SL之间
除了必须保留的256个字节的内存单元外，还必须为中断处理预留足够的内存空间。

用户在程序中不能修改SL的值，数据栈栈指针SP的值必须不小于SL的值。


嵌入式C语言的数据存储方法
====================================
嵌入式C语言是被编译器先翻译成汇编指令集，
然后再将指令集转换为二进制指令代码，
这些二进制代码与微处理器指令长度是一致的。

微处理器的存储空间有 Flash ROM和RAM之分，
一般会将常量，常数等存在Flash ROM中，不常被修改。
而把变量，函数，堆栈等都存放在RAM中，以方便在运行时改变。

寄存器是微处理器中被频繁使用的存储空间，常用来存放做计算的操作数，
因此一个程序被编译成二进制后，分别保存在不同的地方。


RAM @@@@@@@
零初始化数据
初始化数据
堆栈
堆数据

Falsh ROM
常量数据
初始化数据
开始和运行库代码
program.txt

5 嵌入式C语言编写注意事项
============================
数据 类型尽量考虑整形
计算符号多加减，少乘，不除
尽量采用移位运算代替乘除法

变量尽量用局部变量，少用全局变量。
全局变量全部存放在静态存储区，
在程序开始执行时给全局变量分配存储区，程序执行完毕才释放。
全局变量存在于RAM中，而局部变量存在于堆栈中。
如果定义的全局变量太多就有可能导致溢出。

注意变量名字的空间污染。

子程序的嵌套越少越好。
在子程序运行时，当调用下一个子程序时
就需要开辟一个堆栈空间，直到执行到return语句。
才会把这个堆栈去掉。

循环体多用 do-while 少用 for， while
从编译的代码可以看出，do-while 循环中需要一个空间存放退出地址。
相对而言，do-while 循环所需的额外开销最少。


C语言与汇编语混合编程的方法
=========================
1 在C中嵌入汇编指令的注意事项
  不能直接向 PC寄存器赋值，程序跳转只能使用 B或BL 指令实现。

  在使用物理寄存器时，不要使用过于复杂的C表达式，以避免物理寄存器冲突。

  R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0-R3,
  R12,R14用于子程序调用，因此要避免直接使用这些物理寄存器。

  一般不要使用指定的寄存器，而让编译器进行分配。

__asm
}
	instruction [;instruction]
	...
	[instruction]
}

在汇编中使用C定义的全局变量
内嵌汇编不用单独编辑汇编语言文件，
比较简洁，但是有诸多限制，当汇编代码比较多时
一般放在单独的汇编文件中。
这时就需要在汇编和 C之间进行一些数据的传递。
最简单的办法就是使用全局变量。


在汇编中使用C语言中的全局变量 
============================
使用 IMPORT 伪指令引入全局变量，并利用 LDR和STR
指令根据全局变量的地址访问它们。
下面例子是一个汇编代码的函数，它读取全局变量 ABC,
其加2后写回。
AREA ABC, CODE, READONLY
	EXPORT asmsub
	IMPORT ABC
asmsub
	LDR R1, =ABC
	LDR R0, [R1]
	ADD R0, R0, #2
	STR R0, [R1]
	MOV PC, LR
END




在C 程序中调用汇编程序
========================
C 程序调用汇编程序时需要做到以下两步：
在 C程序中使用 extern 关键字声明外部函数
（声明要调用的汇编子程序），即可调用此汇编子程序。
在汇编程序中使 EXPORT 伪指令声明本子程序，使其它程序可以调用此子程序。
另外，汇编程序设置要遵循 AAPCS规则，保证程序调用时参数的正确传递。
C 程序如下：
#include <stdio.h>
extern void strcopy(char *d, const char *s);
int main(void)
{
	const char *srcstr ="First string-source";
	char *dststr ="Second string-destination";
	strcopy(dststr, srcstr);
	return 0;
}

汇编程序如下：
AREA SCopy, CODE, READONLY
ENTRY
EXPORT strcopy
strcopy
	LDRB R2, [R1], #1
	STRB R2, [R0], #1
	CMP R2, #0
	BNE strcopy
	MOV PC, LR
END










