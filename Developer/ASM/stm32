#######################################################

堆栈的概念
===========
1. 按“先进后出（LIFO)”的方式工作的存储区
2. 堆栈以 字为单位 进行操作（入栈和出栈）
3. 堆栈有寄存器堆栈和存储器堆栈
4. 堆栈区域的初始位置称为“栈底”
5. 堆栈的当前位置称为 “栈顶”
6. 堆栈指针 SP指向栈顶位置

堆栈的分类（存储器堆栈）
=====================
1. 按堆栈的生长方式
   向上生长，存储器地址向高地址方向生长
   向下生长，存储器地址向低地址方向生长
2. 按堆栈指针指向的位置
   满堆栈（实栈顶）; 
      堆栈指针指向最后压入的数据，或者指向第一个要读出的数据
   空堆栈（空栈顶）; 
      堆栈指针指向最后压入的数据的上或下一个空位置，或者指向第一个要读出的数据的上或下一个空位置

堆栈的操作
======================
1. 向下生长实栈顶 ->cortex-m3堆栈
2. 向上生长实栈顶
3. 向下生长空栈顶
4. 向上生长空栈顶

cortex-m3堆栈操作
=====================
1. 向下生长的满堆栈
2. 入栈和出栈使用 PUSH和POP 指令 
   PUSH {R0}
   POP  {R0}
3. PUSH和POP指令一次操作多个寄存器
   PUSH {R0-R7, R12, R14} ;保存寄存器列表
   POP  {R0-R7, R12, R14} ;恢复寄存器列表

cortex-m3子程序调用中堆栈的应用
============================
1. 没有嵌套子程序调用过程 
   子程序在调用的过程中把下一条指令在地址保存在 R14寄存器中
2. 嵌套子程序调用过程 
   PUSH {R0-R7, R12, R14} ;保存寄存器列表
   ...                    ;执行处理
   POP  {R0-R7, R12, R14} ;恢复寄存器列表
   BX R14                 ;返回到主调函数

###################################################################

异常与中断
=====================

异常类型==============
Cortex‐M3 在内核水平上搭载了一个异常响应系统,支持为数众多的系统异常和外部中
断。其中,编号为 1-15 的对应系统异常,大于等于 16 的则全是外部中断。除了个别异常
的优先级被定死外,其它异常的优先级都是可编程的

在 NVIC 的中断控制及状态寄存器中,有一个 VECTACTIVE 位段;
另外,还有一个特殊功能寄存器 IPSR。在它们二者的里面,都记录了当前正服务异常的编号

如果一个发生的异常不能被即刻响应,就称它被“悬起”(pending)。不过,少数 fault
异常是不允许被悬起的。一个异常被悬起的原因,可能是系统当前正在执行一个更高优先级
异常的服务例程,或者因相关掩蔽位的设置导致该异常被除能。对于每个异常源,在被悬起
的情况下,都会有一个对应的“悬起状态寄存器”保存其异常请求,直到该异常能够执行为
止,
这与传统的 ARM 是完全不同的。在以前,是由产生中断的设备保持住请求信号。现在
NVIC 的悬起状态寄存器的出现解决了这个问题,即使后来设备已经释放了请求信号,曾经
的中断请求也不会错失。





优先级的定义=============
在 CM3 中,优先级对于异常来说很关键的,它会影响一个异常是否能被响应,以及何
时可以响应。优先级的数值越小,则优先级越高。CM3 支持中断嵌套,使得高优先级异常
会抢占(preempt)低优先级异常。有 3 个系统异常:复位,NMI 以及硬 fault,它们有固定的
优先级,并且它们的优先级号是负数,从而高于所有其它异常。所有其它异常的优先级则都
是可编程的(但不能编程为负数)。
原则上,CM3 支持 3 个固定的高优先级和多达 256 级的可编程优先级,并且支持 128
级抢占(128 的来历请见下文分解——译注)。但是,绝大多数 CM3 芯片都会精简设计,以
致实际上支持的优先级数会更少,如 8 级,16 级,32 级等。它们在设计时会裁掉表达优先
级的几个低端有效位,以达到减少优先级数的目的
通过让优先级以 MSB 对齐,可以简化程序的跨器件移植

应用程序中断及复位控制寄存器(AIRCR)(地址:0xE000_ED00)
10:8 PRIGROUP R/W 0 优先级分组


向量表=====================
当发生了异常并且要响应它时,CM3 需要定位其处理例程的入口地址。这些入口地址
存储在所谓的“(异常)向量表”中。缺省情况下,CM3 认为该表位于零地址处,且各向量
占用 4 字节,因此每个表项占用 4 字节

因为地址 0 处应该存储引导代码,所以它通常是 Flash 或者是 ROM 器件,并且它们的
值不得在运行时改变。然而,为了动态重分发中断,CM3 允许向量表重定位——从其它地
址处开始定位各异常向量。这些地址对应的区域可以是代码区,但也可以是 RAM 区。在 RAM
区就可以修改向量的入口地址了。为了实现这个功能,NVIC 中有一个寄存器,称为“向量
表偏移量寄存器”(在地址 0xE000_ED08 处),通过修改它的值就能定位向量表。但必须注
意的是:向量表的起始地址是有要求的:必须先求出系统中共有多少个向量,再把这个数字
向上增大到是 2 的整次幂,而起始地址必须对齐到后者的边界上。例如,如果一共有 32 个
中断,则共有 32+16(系统异常)=48 个向量,向上增大到 2 的整次幂后值为 64,因此地址
地址必须能被 64*4=256 整除,从而合法的起始地址可以是:0x0, 0x100, 0x200 等

向量表偏移量寄存器(VTOR)(地址:0xE000_ED08)

如果需要动态地更改向量表,则对于任何器件来说,向量表的起始处都必须包含以下向量:
1 主堆栈指针(MSP)的初始值
2 复位向量
3 NMI
4 硬 fault 服务例程
后两者也是必需的,因为有可能在引导过程中发生这两种异常。
可以在 SRAM 中开出一块用于存储向量表。然后在引导完成后,就可以启用内存中的向
量表,从而实现向量可动态调整的功能。


中断输入及悬起行为================
本节开始讨论中断的输入和悬起行为。这也适用于 NMI,只是 NMI 将会立即无条件执
行,除了特殊情况:若当前已经在执行 NMI 服务例程,或者 CPU 被调试器喊停(halted),或
者被一些严重的系统错误锁定(Lock up),则新的 NMI 请求也将悬起。

当中断输入脚被 assert 后,该中断就被悬起。即使后来中断源取消了中断请求,已经被
标记成悬起的中断也被记录下来。到了系统中它的优先级最高的时候,就会得到响应。
但是,如果在某个中断得到响应之前,其悬起状态被清除了(例如,在 PRIMASK 或
FAULTMASK 置位的时候软件清除了悬起状态标志),则中断被取消

当某中断的服务例程开始执行时,就称此中断进入了“活跃”状态,并且其悬起位会被
硬件自动清除,如图 7.10 所示。在一个中断活跃后,直到其服务例程执行完毕,并且返回
(亦称为中断退出,第九章详细讨论)了,才能对该中断的新请求予以响应(即单实例)。
当然,新请求的响应亦是由硬件自动清零悬起标志位。中断服务例程也可以在执行过程中把
自己对应的中断重新悬起(使用时要注意避免进入“死循环”——译注)。

如果中断源咬住请求信号不放,该中断就会在其上次服务例程返回后再次被置为悬起状
态

另一方面,如果某个中断在得到响应之前,其请求信号以若干的脉冲的方式呈现,则被
视为只有一次中断请求,多出的请求脉冲全部错失——这是中断请求太快,以致于超出处理
器反应限度的情况

如果在服务例程执行时,中断请求释放了,但是在服务例程返回前又重新被置为有效,
则 CM3 会记住此动作,重新悬起该中断


Fault 类异常
有若干个系统异常专用于 fault 处理。CM3 中的 Faults 可分为以下几类:
1 总线 faults
2 存储器管理 faults
3 用法 faults
4 硬 fault




















