1. 首先我们将调试器与目标板以及计算机之间的线连接好>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  （此处默认调试器为st-link、对于其他调试器只要稍微更改OpenOCD的启动配置文件就可），
   并将st-link的接口设置到虚拟机上。随后我们通过OpenOCD指令连接调试器：

	openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg
	

2. 在执行完此条指令后该终端就会一直执行OpenOCD的程序了，不要关闭它，我们再打开一个终端界面，
   进入我们的工程目录，比如我这里进入的就是我的libopencm3样例工程下的blink子工程目录

   然后我们使用指令输入调试文件并打开GDB程序>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	arm-none-eabi-gdb blink.elf 
	
	
3. 然后我们在GDB的指令界面中，输入连接指令，连接本地的3333端口>>>>>>>>>>>>>>>>>>>>>>

	(gdb)target remote localhost:3333

   此时我们就将GDB与调试器接上了，运行OpenOCD的终端也会显示收到连接信息
   
   
   
4. 不过我们还没有完成所有的初始操作，此时我们需要输入指令来复位、停止MCU并加载elf文件：
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	(gdb)monitor reset
	(gdb)monitor halt 
	(gdb)load

  这里 monitor意为这向连接的外部软件发送指令，此处即向OpenOCD发送指令，
  因为reset halt等指令不是GDB的内部指令，而是OpenOCD的指令。
  随后的load指令会将启动时输入GDB的elf文件加载入MCU，即下载到MCU的flash。

到这里我们的所有GDB连接的初始操作就完成了，当然我们不仅可以使用OpenOCD启动调试端口，
st-link的驱动也也可以，使用指令：st-util就可以启动它，不过st-link驱动默认的端口是4242



5. arm-none-eabi-gdb的调试指令

在我们将elf调试文件加载到MCU中后，我们就可以进行调试操作了。首先来介绍一下GDB调试的基本指令：

>>>	l，list指令的缩写，意为列出当前执行的源代码。同时输入指令后重复按回车等效于再次输入上次的指令 
>>>	c ，continue的缩写，在嵌入式GDB中我们不能使用RUN指令来运行代码，相应的我们需要continue指令来运行。
>>>	b ，break缩写，用于在程序中打断点，使用方式有很多种
>>>	b 16，在当前低16行代码出加断点。
>>>	b i=1，当i等于1时停止，类似于这种条件式断点的方式也是GDB独有的一种强大功能。
>>>	b main，在main函数的入口打断点。
>>>	i b ，info break缩写，显示当前设置的断点信息。如下面这个查到了在main函数处有两个断点，序号分别为1 和 2。

>>>	d break ，delet break 缩写，删除所有断点
>>>	d break 1 ，删除序号为1的断点

>>>	s，step缩写，会进入子函数的单步运行

>>>	n，next缩写，即会跳过子函数的单步运行

>>>	u，until缩写使用时后方加行号如： u 16 即运行到第16行

>>>	finish，完成并跳出当前的子函数

>>>	p，print缩写，使用时后面加变量名称如：p tmp ，用来显示变量数值

>>>	display ，使用时后面加变量名称如：display tmp ，用于跟踪变量数值，在每次执行停下时会自动显示变量数值。

>>>	bt，查看堆栈

>>>	q/Ctrl+d，使用q即quit指令或快捷键Ctrl+d来正常退出GDB


在GDB的指令窗口我们输入>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(gdb)-		对就是一个 减号，然后回车我们来见证奇迹的时刻

