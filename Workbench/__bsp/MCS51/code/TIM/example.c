#include <reg51.h>
#define uchar unsiged char

uchar count;	//用于记录发生了多少此中断的记录
uchar second;
/* 共阳极数码管编码表 */
uchar code table[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
			0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};

int main(void)
{
	TMOD = 0x01;	//启用定时器0，工作模式1
	TH0  = (65536-50000)/256;	//装初值
	TL0  = (65536-50000)%256;	//装初值
	EA   = 1;	//打开总中断
	ET0  = 1;	//打开定时器0
	TR0  = 1;	//启动定时器0		
	while (1)
	{
		if (count == 20)
		{
			count = 0;
			second++;
			if (second > 100)
				second = 0;
			display(second);
		}
		
	}
	
}

void display(uchar dat)
{
	uchar shi, ge;
	shi = dat/10;
	ge  = dat%10;
	
	wei0 = 0;
	P0 = tab[shi];
	delay_ms(3);
	wei0 = 1;
	
	wei1 = 0;
	P0 = tab[shi];
	delay_ms(3);
	wei1 = 1;
	
}

void timer0() interrupt 1	//定时器0的中断优先等级是1
{

/* 因为定时器1不具有自动重装载功能，所以每次自动记满数就会自动清零，从 0 开始计数*/
	TH0  = (65536-50000)/256;	//重新装初值
	TL0  = (65536-50000)%256;	//重新装初值
	count++;
	
	
}


###############################################################################
定时器工作模式

1. 工作模式 0
当 TOM(T1M) = 00 时定时器设定为工作模式0，此定时器(0/1)工作在 13位定时状态。

其中 TH0是高 8位加法计数器。
TL0是低 5位加法器，(TL0只用到了低5位，高3位未用)
低5位就是逢 2的5次方即 32 向高 8位进 1.


2. 工作模式 1
当 TOM(T1M) = 01 时定时器设定为工作模式1，此定时器(0/1)工作在 16位定时状态。

此时定时器的 TH0,TLO都是 8位加法计数器。
低8位逢 2的8次方即 256向高8位进 1.

定时器的定时时间：
	T = (65536 - x)*Tcy
	

3. 工作模式 2

当 TOM(T1M) = 10 时定时器设定为工作模式2，此定时器(0/1)被设定自动重装载寄存器。
TL0 为8位加法计数器
TH0 为存放8位加法计数器的初始值
TH0,TL0 的值由程序预置
工作模式 2 中定时器的定时时间由下式确定：
	T = (256 - x)*Tcy


3. 工作模式 3

当 TOM(T1M) = 11 时定时器设定为工作模式3,
只有定时器0可以在此模式下工作，
如果把定时器1设置位工作模式3，则定时器1停止工作

TH0 , TL0成为2个独立的 8位计数器，它的工作情况与 模式0,1相似；
差别在于定时范围
	T=(256-X)*Tcy


###############################################################################





